<!DOCTYPE html>
<html lang="en">
<head>
  <meta
  name="viewport"
  content="width=device-width,
           initial-scale=1.0,
           maximum-scale=1.0,
           user-scalable=no">
  <!-- load the Vercel Insights script -->
<script defer src="/_vercel/insights/script.js"></script>

 <!-- iOS full-screen meta tags -->

  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ADAFCO Trainer">
  <link rel="apple-touch-icon" href="/icons/icon-192x192.png",>
<meta name="mobile-web-app-capable" content="yes">
  <!-- Trainerâ€™s own manifest -->
  <link rel="manifest" href="/ADAFCO-manifest.json">

  <meta charset="UTF-8">
  <title>ADAFCO Bullseye/Air Battle Trainer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <style>
    :root {
      --bg: #0a0a0d; --icc: #27e835;
      --braa: #0ea5e9; --track: #ff5757; --text: #f8f8f8;
      --yellow: #ffd60a; --warn: #ff4d4d;
    }
    *, *::before, *::after {
      box-sizing: border-box;
      font-family: Arial, Helvetica, sans-serif;
    }
  
    html {
      height: 100%;
    }
    body {
    
  background: var(--bg);
      margin: 0;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    
    }
    header {
      display: flex; flex-direction: column; align-items: center;
      padding: .5rem 1rem; background: #111; gap: .5rem; z-index: 3;
    }
    #controls { display: flex; gap: .75rem; }
    button {
      padding: .25rem .8rem; border: none; border-radius: 6px;
      font-weight: 600; cursor: pointer; white-space: nowrap;
    }
    #practiceBtn { background: var(--icc); color: #000; }
    #tagsBtn, #helpBtn { background: var(--braa); color: #000; }
    #compassBtn { background: var(--yellow); color: #000; }
    #status { font-size: .9rem; z-index: 3; }
    #feedback { font-size: .8rem; color: var(--warn); min-height: 1em; z-index: 3; }
    #scope {
      flex: 1; min-height:0; width: 100%; background: var(--bg);
      position: relative; z-index: 1;
    }
    #mobileControls {
      display: none; position: fixed; bottom: 0; left: 0; width: 100%;
      background: rgba(17,17,17,0.9); padding: .5rem 0; z-index: 4;
      flex-wrap: wrap; justify-content: space-around;
    }
    #mobileControls button {
      flex: 1; margin: .25rem; min-width: 40px; font-size: 1rem;
    }
    @media (max-width: 768px) {
      #mobileControls { display: flex; }
    }
    #helpOverlay {
  display: none;
  position: fixed;
  top: 70px;
  left: 50%;
  transform: translateX(-50%);
  background: #222;
  color: #f8f8f8;
  padding: 1rem;
  border: 1px solid #444;
  border-radius: 8px;
  z-index: 5;
  max-width: 380px;

  /* new: limit height and allow scrolling */
  max-height: 70vh;
  overflow-y: auto;
}

    #helpOverlay h3 { margin-top: 0; color: var(--icc); }
    #helpOverlay button {
      margin-top: 1rem; background: var(--track); color: #fff;
      cursor: pointer;
    }
    #cursorLabel {
      position: fixed; pointer-events: none; z-index: 6;
      background: rgba(0,0,0,0.7); border-radius: 4px;
      padding: 2px 5px; font-family: monospace; font-size: .8rem;
      color: var(--text);
    }
    #cursorLabel .be { color: var(--yellow); font-weight: 600; }
    #cursorLabel .braa { display: block; color: var(--braa); font-size: .7rem; }
    .card {
      position: fixed; top: 10px; left: 10px;
      background: #181818; border: 1px solid #333;
      padding: 1rem 1.5rem; border-radius: 8px; z-index: 15;
    }
    .card h3 {
      margin: 0 0 .4rem; color: var(--icc); font-size: 1.1rem;
    }
    .card button {
      margin-top: .8rem; background: var(--track); color: #fff; cursor: pointer;
    }
    #uiLayer {
  position: absolute;
  top: /* your header height, e.g. */ 60px;
  left: 0;
  width: 100%;
  height: calc(100% - 60px);
  pointer-events: none;            /* so canvas panning/zooming still works through it */
  transform-origin: 0 0;           /* top-left as the pivot for scale+translate */
}

/* but let your tooltips/cards themselves receive pointer events */
#uiLayer .radar-return,
#uiLayer .card {
  pointer-events: auto;
  transform-origin: 0 0;           /* so each child scales from its own top-left */
}
.radar-return{
  user-select: none;   /* text canâ€™t be highlighted, caret never shows */
  cursor: default;     /* optional â€“ normal arrow instead of I-beam */
}

    /* â”€â”€â”€ GAME OVER OVERLAY STYLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#gameOverOverlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 999;
}
#gameOverBox {
  text-align: center;
  color: #fff;
}
#gameOverBox h1 {
  font-size: 4rem;
  margin-bottom: 1rem;
}
#gameOverBox p {
  font-size: 2rem;
  margin-bottom: 1.5rem;
}
#gameOverBox button {
  font-size: 1rem;
  padding: .75rem 1.5rem;
  background: var(--track);
  color: #fff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}
/* â”€â”€â”€ LEVEL COMPLETE OVERLAY STYLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#levelOverlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}
#levelBox {
  background: #222;
  color: #fff;
  padding: 2rem;
  border-radius: 8px;
  text-align: center;
}
#levelBox h2 {
  margin: 0;
  font-size: 3rem;
}
#fireballBtn {
  position: fixed;
  bottom: 3rem;
  right: 1rem;
  z-index: 10;
  background: var(--warn);
  color: #fff;
}
@media (max-width: 768px) {
  .card,
  .card2 {
    top: 100px !important;
  }
}
/* Make both cards semiâ€‘transparent */
.card,
.card2 {
  background: rgba(24, 24, 24, 0.8) !important;  /* was #181818 */
  border: 1px solid rgba(51, 51, 51, 0.8);
}

/* Style the close â€œÃ—â€ button */
.card .close-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 20px;
  height: 20px;
  padding: 0;
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: 50%;
  color: #fff;
  font-size: 14px;
  line-height: 20px;
  text-align: center;
  cursor: pointer;
}

@media (max-width: 768px) {
  #controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    justify-content: center;
  }

  #controls button {
    flex: 1 1 auto;       /* allow buttons to shrink */
    min-width: 0;         /* required for flex shrinking */
    white-space: nowrap;  /* keep text on one line */
    overflow: hidden;
    text-overflow: ellipsis;
    padding: 0.3rem 0.5rem;

    /* shrink text between .5rem and .9rem based on viewport */
    font-size: clamp(0.5rem, 2.5vw, 0.9rem);
  }
}/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ACTION BAR â€“ bottomâ€“right container for REDWOOD + FIREBALL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#actionBar{
  position:fixed;
  bottom:3rem;
  right:1rem;
  display:flex;
  align-items:flex-end;   /* keep bottoms aligned */
  gap:.5rem;
  z-index:10;
}

/* wrapper gives a local positioning context */
#redwoodWrap{ position:relative; }

/* main REDWOOD button â€“ same footprint as FIREBALL */
#redwoodBtn{
  min-width:120px;
  height:40px;
  padding:0 .75rem;
  display:flex;           /* perfect label centering */
  align-items:center;
  justify-content:center;
  font-weight:700;
  border:none;
  border-radius:6px;
  cursor:pointer;
  transition:background .2s;
}
#redwoodBtn.cold{ background:var(--icc);  color:#000; }  /* green */
#redwoodBtn.hot { background:var(--warn); color:#fff; }  /* red   */

/* 2 Ã— 2 quadrant grid â€“ hidden by default, appears above the button */
#redwoodMenu{
  position:absolute;
  bottom:100%;            /* tucks up against the buttonâ€™s top edge */
  left:0;
  width:100%;
  transform:translateY(-4px);  /* tiny gap */
  background:#111;
  padding:.4rem;
  border-radius:6px 6px 0 0;
  display:none;           /* collapsed */
  grid-template-columns:repeat(2,1fr);
  gap:4px;
}
/* show when wrapper has .open */
#redwoodWrap.open #redwoodMenu{ display:grid; }

/* quadrant squares */
#redwoodMenu button{
  height:40px;
  border:none;
  border-radius:4px;
  background:#333;
  color:#fff;
  font-weight:700;
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  user-select:none;
}
/* â”€â”€â”€ FORCE FIREBALL TO MATCH REDWOOD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#fireballBtn{
  /* kill any earlier â€œposition: fixedâ€ or odd offsets */
  position: static !important;

  /* identical footprint to #redwoodBtn */
  width: 120px  !important;   /* keep in sync with REDWOOD */
  height: 40px  !important;
  padding: 0 .75rem !important;

  /* same visual formatting guarantees centred label */
  display: flex  !important;
  align-items: center !important;
  justify-content: center !important;
  font-weight: 700 !important;

  /* preserve your colour scheme */
  background: var(--warn) !important;
  color: #fff !important;

  /* keep default border-radius / borderless look */
  border: none !important;
  border-radius: 6px !important;
  cursor: pointer  !important;
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   SHRINK ACTION-BAR CONTROLS
   (override must come after earlier #redwoodBtn / #fireballBtn)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* main buttons */
#redwoodBtn,
#fireballBtn{
  width: 100px !important;   /* â†“ narrower  (was 120) */
  height: 32px !important;   /* â†“ shorter   (was 40)  */
  padding: 0 .65rem !important;
  font-size: .9rem !important;   /* dial text down a hair */
}

/* quadrant squares */
#redwoodMenu button{
  align-items: left;
  height: 32px !important;   /* match main-button height */
}
/* â”€â”€ Move Redwood to bottom-left on phones â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@media (max-width: 768px) {
  #actionBar {
    left: 1rem;     /* 1rem from the left edge */
    right: auto;    /* cancel the right:1rem */
    bottom: 3rem;   /* same vertical offset you already use */
  }
}

/* in your <style> */
    #redwoodMenu button.cold {
  background: var(--icc);   /* green */
  color: #000;
}
#redwoodMenu button.hot {
  background: var(--warn);  /* red */
  color: #fff;
}
.overlay {
  position: fixed; top:0; left:0; width:100%; height:100%;
  background: rgba(0,0,0,0.85); display:flex;
  align-items:center; justify-content:center; z-index:2000;
}
.overlayBox {
  background:#111; color:#f8f8f8; padding:2rem; border-radius:8px;
  max-width:400px; text-align:center;
}
.overlayBox button {
  margin-top:1rem; padding:.5rem 1rem; font-size:1rem;
  background:var(--icc); color:#000; border:none; border-radius:4px;
  cursor:pointer;
}
#modeSelectOverlay button { 
  display:block; width:100%; margin:0.5rem 0;
  padding:.75rem; font-size:1rem; 
  background:var(--braa); color:#000; 
  border:none; border-radius:4px; cursor:pointer;
}
#gameControls button {
  margin:0 .25rem; padding:.3rem .6rem; font-size:1rem;
  background: var(--icc); color:#000; border:none; border-radius:4px;
  cursor:pointer;
}
/* hide by default */
#dictateBtn { display: none; }
/* show when on a touchscreen device with iOS Safari UA quirk */
@supports (-webkit-touch-callout: none) {
  #dictateBtn { display: block; }
}
/* in your main stylesheet */
/* desktop & mobile positioning as you already have */
#micBtnRadio {
  position: fixed;
  right: 1rem;
  
    /* below Redwoodâ€™s z-index:10 but above mobileControls z-index:4 */
}
#cardLayer {
  pointer-events: none;              /* let wheel/pinch pass through */
  transform-origin: top left;        /* pivot from the top-left corner */
  transform: scale(var(--card-scale,1)) !important;
}

#cardLayer .card {
  pointer-events: auto;              /* only the cards themselves still catch clicks */
}

/* If you ever need separate desktop/mobile adjustments, you can still wrap them in @media as before */
@media (max-width: 768px) {
  #micBtnRadio {
    bottom: 3.2rem;  /* tweak if needed */
    z-index: 5;
  }
}
/* prevent any native touch/pinch/scroll actions on the canvas itself */
#scope {
  touch-action: none;
}

#fireballBtn {
  display: none !important;
.radar-return::before {
  content: "+";
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  font-size: 12px;
  line-height: 12px;
  color: #fff;
  pointer-events: none; /* let the hover still go through to the element itself */
}

}
.radar-return {
  position: absolute;
  width: 8px;
  height: 8px;
  cursor: pointer;
  pointer-events: auto;     /* â† allow hover */
  z-index: 10;              /* â† sit above everything else */
  transform-origin: center center;
  /* scale down/up based on zoom */
  transform: scale(var(--card-scale,1));
}

/* if you want tooltips or cards to scale too */
.card, .radar-return .tooltip {
  transform-origin: top left;
  transform: scale(var(--card-scale,1));
}
.radar-return .tooltip {
  display: none;
  position: absolute;
  top: -4em;
  left: 1em;
  background: rgba(0,0,0,0.5);
  color: #fff;
  padding: 0.25em 0.5em;
  border-radius: 4px;
  font-size: 0.8rem;
  line-height: 1.2;
  white-space: nowrap;
}
.radar-return:hover .tooltip {
  display: block;
}
#returnLayer {
  position: absolute;
  transform-origin: top left;   /* important - matches canvas */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;     /* let only the .radar-return children catch events */
  z-index: 5;               /* above canvas, below UI */
}
/* when #returnLayer has the .inert class, disable ALL pointer events on it and its markers */
#returnLayer.inert,
#returnLayer.inert .radar-return {
  pointer-events: none !important;
}
#uiLayer .card {
  transform-origin: top left;
  transform: scale(var(--card-scale,1));
  pointer-events: none;            /* â† let gestures pass through */
}

/* only the close-button should catch clicks */
#uiLayer .card .close-btn {
  pointer-events: auto;
}
/* â”€â”€â”€ compact radar-return popup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#radarInfo{
  position:absolute;        /* follow the cursor */

  /* â€œway smallerâ€ footprint */
  width:110px;
  height:70px;
  max-width:110px;
  max-height:70px;

  background: rgba(0,0,0,0.5);
  border:1px solid #333;
  border-radius:8px;
  padding:.5rem .75rem;
  color:#f8f8f8;
  font-size:.75rem;          /* smaller text so it fits */
  line-height:1;
  overflow:auto;

  display:none;              /* JS still toggles this */
  pointer-events:none;       /* stays transparent to clicks */
  z-index:20;
}


  </style>
</head>
<body>
    <div id="disclaimerOverlay" class="overlay">
        <div class="overlayBox">
          <h2>Disclaimer</h2>
          <p>
            This simulator uses unclassified data only. Do NOT use any ranges, procedures
            or contracts shown here for real mission planning. This software is not
            endorsed by, nor affiliated with, the U.S. Department of Defense.
          </p>
          <button id="ackDisclaimer">I Understand</button>
        </div>
      </div>
      
      <div id="modeSelectOverlay" class="overlay" style="display:none;">
        <div class="overlayBox">
          <h2>Select Mode</h2>
          <button id="btnBullseye">Bullseye Practice</button>
          <button id="btnAirBattle">Fight Air Battle</button>
        </div>
      </div>
  
  <header>
    <div id="controls">
        <div id="gameControls" style="display:none;">
            <button id="pauseBtn">âšâš</button>
            <button id="stepBtn">â€º</button>
            <button id="ffBtn">â€ºâ€º</button>
            <button id="skipBtn">Next LevelÂ»</button>
          </div>
          
      <button id="tagsBtn">TAGS: OFF</button>
      <button id="compassBtn">Compass: OFF</button>
      <button id="mapBtn">Map</button>
      <button id="helpBtn">Help</button>
    </div>
    <div id="status">ADW RED, WCS HOLD</div>
    <div id="score">Score: 0</div>
    <div id="feedback"></div>
    <!-- place this somewhere in your page -->
<button id="dictateBtn" style="position:fixed;bottom:1rem;left:1rem;z-index:1000;">
  ğŸ¤ Dictate
</button>
<input id="dictateInput" type="text"
       style="position:fixed;bottom:1rem;left:1rem;
              width:1px;height:1px;opacity:0;pointer-events:none;"
       autocomplete="off" autocorrect="off" autocapitalize="none" />

  </header>

  <!-- Action bar (bottom-right) -->
<div id="actionBar">
    <div id="redwoodWrap">
      <button id="redwoodBtn" class="cold">REDWOOD</button>
      <div id="redwoodMenu">
        <button data-q="NW">NW</button>
        <button data-q="NE">NE</button>
        <button data-q="SW">SW</button>
        <button data-q="SE">SE</button>
      </div>
    </div>
  
    <button id="fireballBtn" disabled>FIREBALL</button>
  </div>
  
  
  
<canvas id="scope"></canvas>
<div id="uiLayer">
  <div id="returnLayer"></div>
  <div id="cardLayer"></div>
</div>
  <span id="timerDisplay" style="margin-left:1rem;">10.0&nbsp;s</span>

    <div id="helpOverlay">
     
        <h3>How to Play</h3>
        <p>
          You are the ADAFCO, operating from the C2 TOC Callsign "Bigfoot", coordinating with the TD in the ICC Callsign "Guardian". Your mission is to execute a 360Â° Point-Defense operation: prevent fratricide, manage track engagement, and prosecute hostile air threats as directed by the SL. Success requires speed, judgment, and decisive task prioritization.
        </p>
      
        <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Mission Flow -->
  <h4>Mission Flow</h4>
  <ol>
    <li><strong>For best training value:</strong> All internal calls to the Crew and the SL should be simulated.<br></li>
    <li>
      <strong>COVER&nbsp;Phase</strong><br>
      The Senior Director (SL) calls:
      <em>â€œCOVER Track 12345, B/E&nbsp;123/45.â€</em><br>
      â€¢ <kbd>Left-click</kbd> the track.<br>
      â€¢ Evaluate geometry &amp; ID, then press and hold [Ctrl] to activate radio P/T.<br>
      â€¢ Voice to ICC "Guardian, Bigfoot, Cover Track 12345, 27 Thousand, Hostile" or "Cover Group Bullseye 123/45"...<br>
      â€¢ Use the appropriate hotkey to notify the Crew/SL once Birds Affirm or Birds Negate.
        <kbd>A</kbd> (<em>AFFIRM</em>) or <kbd>N</kbd> (<em>NEGATE</em>).
    </li>

    <li>
      <strong>AFFIRM&nbsp;â†’ ENGAGE</strong><br>
      â€¢ The SL will order <em>ENGAGE</em> automatically or after your AFFIRM.<br>
      â€¢ When the SL gives an Engage order, the track will be tagged <code>ENGAGE</code>.<br>
      â€¢ Voice to ICC "Guardian, Bigfoot, Engage Track 12345, 27 Thousand, Hostile" or "...Engage Group Bullseye 123/45"...<br>
      â€¢ Two missiles are launched by ICC from the nearest in-geometry Firing Unit.
      â€¢ Press <kbd>W</kbd> (<em>AWAY</em>) to notify the Crew/SL once ICC voices "Birds Away" on a track.
    </li>

    <li>
      <strong>VANISH / HOLD FIRE</strong><br>
      Hits remove the track automatically. 
      To abort an intercept and prevent fraticide, voice to ICC "Guardian, Bigfoot, Hold Fire track 12345" (engaged track).<br>
      or press<kbd>H</kbd> (<em>HOLD FIRE</em>) with the engaged track selected.
    </li>
    
  </ol>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Controls -->
  <h4>Controls &amp; Hotkeys</h4>
  <table>
    <tr><th colspan="2">Action keys</th></tr>
    <tr><td><kbd>A</kbd></td><td>AFFIRM COVER</td></tr>
    <tr><td><kbd>N</kbd></td><td>NEGATE COVER</td></tr>
    <tr><td><kbd>W</kbd></td><td>BIRDS AWAY</td></tr>
    <tr><td><kbd>H</kbd></td><td>HOLD FIRE (cancel shot)</td></tr>
    <tr><td><kbd>K</kbd></td><td>KILL (manual vanish)</td></tr>
    <tr><td><kbd>O</kbd></td><td>Re-orient selected Patriot radar<br>
        &nbsp;&nbsp;â€“ Click the new azimuth on scope</td></tr>
        
        

    <tr><th colspan="2">Navigation</th></tr>
    <tr><td><kbd>â†‘ â†“ â† â†’</kbd></td><td>Pan map</td></tr>
    <tr><td><kbd>+</kbd>/<kbd>â€“</kbd></td><td>Zoom in / out</td></tr>
    <tr><td><kbd>Shift + Drag</kbd></td><td>Multi-select box</td></tr>
    <tr><td><kbd>Double-drag</kbd></td><td>Zoom window to box</td></tr>

    <tr><th colspan="2">Mobile toolbar<br></th></tr>
    <tr><td colspan="2">
      <code>A&nbsp;N&nbsp;W&nbsp;H&nbsp;O&nbsp;K</code> buttons replicate the keys.  
      Pinch-zoom and one-finger drag pan the map.
    </td></tr>
  </table>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI Buttons -->
  <h4>Top Bar Buttons</h4>
  <ul>
    <li><strong>TAGS</strong> â€“ cycle scope overlays
      (OFF â†’ B/E â†’ JTN â†’ INFO â†’ ALL â†’ ALT)</li>
    <li><strong>Compass</strong> â€“ overlay fixed 8-point compass rings</li>
    <li><strong>Map</strong> â€“ toggle sat/outline background</li>
    <li><strong>Help</strong> â€“ youâ€™re here</li>
  </ul>

  <h4>Action Bar (bottom-right)</h4>
  <ul>
    <li><strong>REDWOOD</strong> â€“ arms â€œweapons-hotâ€ in a quadrant<br>
        â€¢ When REDWOOD HOT is active (red) ADAFCO holds engagment authority in that quadrant.</li>
        â€¢ Voice to SL "SL, ADAFCO, request REDWOOD HOT, NW Quadrant</li>
        â€¢ SL will assess for a few seconds and Respond with "Approved" or "Denied" based on number of friendlies and number of hostiles.</li>
        â€¢ You can also request nonverbally by tapping <em>REDWOOD</em> â†’ choose <em>NW NE SW SE</em>.<br>
        â€¢ when activated, no ROE penalties in that sector until the SL deactivates it.</li>
    <li><strong>FIREBALL</strong> â€“ global TBM defense switch<br>
        â€¢ Arms Patriots (50 NM gate) and NASAMS (20 NM gate) for all incoming TBM waves.</li>
        â€¢ Activated by voicing "Crew FIREBALL FIREBALL FIREBALL" or "Crew, FIREBALL NW Quadrant."<br>
        â€¢ You can also activatie nonverbally by tapping <em>FIREBALL</em>.<br>
    <li><strong>State Checks</strong> â€“ You may request "What State" from "Guardian" at any time.<br>
        â€¢ Weapons Green <em>More than 50% interceptors remaining per FU</em>.<br>
        â€¢ Weapons Yellow <em>25%-50% interceptors remaining per FU</em>.<br>
        â€¢ Weapons Red <em> Less than 25% interceptors remaining per FU</em>.<br>
  </ul>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Scoring -->
  <h4>Scoring</h4>
  <ul>
    <li><strong>+1</strong> Valid missile kill</li>
    <li><strong>+2</strong> FIREBALL intercept</li>
    <li><strong>â€“0.5</strong> Contract Violation (communicate engagement status via [A] and [W] Hotkeys)</li>
    <li><strong>â€“1</strong> Birds/shots trashed (miss if no geometry)</li>
    <li><strong>â€“5</strong> ROE violation (engaged without authority)</li>
    <li><strong>â€“6</strong> Friendly fire (miss)</li>
    <li><strong>â€“20</strong> Fratricide</li>
    <li><strong>â€“5</strong> TBM craters island</li>
    <li><strong>â€“7</strong> ABT damages an asset</li>
  </ul>

    <h4>Mission Success &amp; Failure</h4>
  <p>
    <strong>Success:</strong> You win when you successfully defend the island from a full air attack level and maintain a positive score.<br>
    <strong>Failure:</strong> You lose if DAL/assets are impacted 5 times, or 5 contract/ROE violations occur.<br>
    The mission ends immediately if:<li><strong>Friendly Fire / Fratricide</strong> â€“ an interceptor kills a friendly track</li>
    
  </ul>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Radar & Weapons -->
  <h4>Weapon Systems</h4>
  <dl>
    <dt>Patriot FUs Ã— 4</dt>
    <dd>
      Magazine per FU: 12 PAC-2, 16 PAC-3, 24 MSE  
      <br>Reload: 15 min 
      <br>Radar wedge: 60 NM / Â±60Â° &nbsp;(<kbd>O</kbd> to slew, 90 s red)
      <br>PTL can be set with [O] Hotkey or by directingP: "Guardian, Bigfoot, set/re-orient, SW PTL 270 degress."
    </dd>

    <dt>NASAMS FU x 1</dt>
    <dd>
      18 Ã— AIM-120, 15 NM ring. Reload 15 min.  
      Auto-fires on TBM at 20 NM if FIREBALL armed.
    </dd>

    <dt>TPS-75</dt>
    <dd>
      Island-wide search radar. Can detect out to ~200 NM (depending on track altitude). May be damaged by bombs/cruise missiles
      (10 min downtime).</dd>
  </dl>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Threat Types -->
  <h4>Threat Types</h4>
  <ul>
    <li><strong>Hostile aircraft</strong> â€“ maneuver, drop precision bombs at 10 NM &amp; 5 NM. Heavy groups start at Level 3+</li>
    <li><strong>TBM waves</strong> â€“ groups of 1 to 3 ballistic missiles start at Level 3+. Use FIREBALL to prime auto-engage.</li>
    <li><strong>Cruise missiles</strong> â€“ low-alt clustered shots start at Level 2+.</li>
    <li><strong>Friendlies</strong> â€“ Returning to the Island on Procedural MRR. Descend from 20 NM / 200 MSL; IDENT, Do not engage!</li>
  </ul>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Levels -->
  <h4>Levels &amp; Progression</h4>
  <ol>
    <li><strong>Level 1</strong> â€“ 10 hostiles.</li>
    <li><strong>Level 2</strong> â€“ +5 hostiles, adds cruise-missile raid.</li>
    <li><strong>Level 3</strong> â€“ TBM wave â€(+ FIREBALL).</li>
    <li><strong>Level 4+</strong> â€“ Random radar outages.</li>
  </ol>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Closing -->
  <p style="text-align:center">
    <button id="closeHelp">Close</button>
  </p>
</div>
      

  <div id="mobileControls">
    <button data-key="a">A</button>
    <button data-key="n">N</button>
    <button data-key="w">W</button>
    <button data-key="h">H</button> 
    <button data-key="o">O</button>   
    <button data-key="k">K</button>
  </div>
  

  <div id="cursorLabel"></div>


  <script>

    // Detect iOS devices
// detect iOS
const isIOS = /iP(hone|od|ad)/.test(navigator.userAgent);

// wrap speechSynthesis.speak so every utterance is slowed on iOS
(function(){
  const origSpeak = speechSynthesis.speak.bind(speechSynthesis);
  speechSynthesis.speak = utterance => {
    if (isIOS) {
      utterance.rate = 1.3;     // or 0.9 if you prefer even slower
      utterance.pitch = 1.3;    // keep pitch natural
    }
    return origSpeak(utterance);
  };
})();



  // call once on the very first tap anywhere
function primeAudio() {
  window.removeEventListener('touchend', primeAudio);
  // unlock Web AudioContext
  const Actx = window.AudioContext || window.webkitAudioContext;
  if (Actx) {
    const ctx = new Actx();
    if (ctx.state === 'suspended') ctx.resume();
  }
  // fire an empty utterance so future .speak() calls work
  speechSynthesis.speak(new SpeechSynthesisUtterance(''));
}
window.addEventListener('touchend', primeAudio, { once: true });

    
const btn = document.getElementById('dictateBtn');
const inp = document.getElementById('dictateInput');

btn.addEventListener('click', () => {
  // show the native keyboard (with mic button) by focusing
  inp.value = '';
  inp.style.pointerEvents = 'auto';
  inp.style.opacity = 1;
  inp.focus();
});

// when the user finishes (either taps â€œDoneâ€ or leaves the field)
inp.addEventListener('blur', () => {
  const txt = inp.value.trim();
  if (txt) onTranscript(txt);    // reuse your voiceâ€parser
  // hide it again
  inp.style.pointerEvents = 'none';
  inp.style.opacity = 0;
});

// optional: submit on Enter too
inp.addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    e.preventDefault();
    inp.blur();
  }
});

function syncReturnLayer(){
  returnLayer.style.transform =
    `translate(${-offX * scale}px, ${-offY * scale}px) scale(${scale})`;
}
/* fixed sidebar card for radar-return details */
const radarInfo = document.createElement('div');
radarInfo.id = 'radarInfo';
document.body.appendChild(radarInfo);


// at the top of your script, pick whatever onâ€‘screen radius you like:
const CLICK_RADIUS_SCREEN = 15;  // pixels on the canvas
  /* -------------------------------------------------------------
     GLOBAL RUN-STATE FLAGS â€“ must be declared before animate()
  ------------------------------------------------------------- */
  let paused       = false;   // true â‡’ physics/update loop is frozen
  let fastForward  = false;   // true while the â€ºâ€º button is held
  const FF_FACTOR  = 4;       // 4Ã— speed-up when fast-forwarding

  let assetHits        = 0;   // ++ every time we take a hit
let fratricideFatal  = false;

// Holds all the little â€œ+â€ markers
let radarReturns = [];

  // *** 1) Capture all the new UI elements ***
  const disclaimer  = document.getElementById('disclaimerOverlay');
  const ackBtn      = document.getElementById('ackDisclaimer');
  const modeSelect  = document.getElementById('modeSelectOverlay');
  const btnBullseye = document.getElementById('btnBullseye');
  const btnAir      = document.getElementById('btnAirBattle');
  const controls    = document.getElementById('gameControls');
  const pauseBtn = document.getElementById('pauseBtn');
const stepBtn  = document.getElementById('stepBtn');
const ffBtn    = document.getElementById('ffBtn');
const skipBtn  = document.getElementById('skipBtn');
skipBtn.addEventListener('click', goNextLevel);


// â”€â”€â”€ PER-LEVEL METRICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STATS = {
  missilesUsed : { pac2:0, pac3:0, mse:0, aim120:0 },
    engagementsGood : 0,
    engagementsBad  : 0,
  assetsHit    : 0,
  roeViolations: 0,
  fratricide   : 0,
  radarDowntime: 0,          // seconds
  impacts      : []          // â† NEW â€“ list of what got hit
};

function resetStats () {
  for (const k in STATS.missilesUsed) STATS.missilesUsed[k] = 0;
  STATS.engagementsGood = STATS.engagementsBad =
  STATS.assetsHit      = STATS.roeViolations =
  STATS.fratricide     = STATS.radarDowntime = 0;
  STATS.impacts.length = 0;
}

// will gate automatic missionâ€‘fail on fratricide or too many hits
let allowMissionFail = true;

  /* â”€â”€â”€ GAME-TIME CONTROLS (Pause / Step / FF / Skip) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

pauseBtn.addEventListener('click', () => {
  paused = !paused;
  pauseBtn.textContent = paused ? 'â–¶' : 'âšâš';
  });

// speed factors
const QUAD_FACTOR = 4;
const TEN_FACTOR   = 10;


let fastFactor  = 1;       // NEW â€“ 1 Ã—, 2 Ã—, or 4 Ã—

// â€º  (2 Ã—) while you hold it
stepBtn.addEventListener('mousedown',  () => { fastForward = true; fastFactor = QUAD_FACTOR; });
stepBtn.addEventListener('touchstart', () => { fastForward = true; fastFactor = QUAD_FACTOR; }, {passive:true});
['mouseup','mouseleave','touchend','touchcancel'].forEach(ev =>
  stepBtn.addEventListener(ev, () => { fastForward = false; fastFactor = 1; }, {passive:true})
);

// â€ºâ€º (4 Ã—) while you hold it
ffBtn .addEventListener('mousedown',  () => { fastForward = true; fastFactor = TEN_FACTOR; });
ffBtn .addEventListener('touchstart', () => { fastForward = true; fastFactor = TEN_FACTOR; }, {passive:true});
['mouseup','mouseleave','touchend','touchcancel'].forEach(ev =>
  ffBtn.addEventListener(ev, () => { fastForward = false; fastFactor = 1; }, {passive:true})
);

  // *** 2) Helper to show inâ€‘game controls ***
  function onGameStart() {
    controls.style.display = 'block';
    // hide whatever â€œPracticeâ€ button you once had:
    const oldPractice = document.getElementById('practiceBtn');
    if (oldPractice) oldPractice.style.display = 'none';
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   TIMED BULLSEYE-PRACTICE MODULE
   ------------------------------------------------------------
   â€¢ Ten rounds per level.
   â€¢ Level-1 time limit = 10 s, â€“2 s each level (min 2 s).
   â€¢ +1 if correct within the limit, -1 if wrong / timed-out.
   â€¢ After 10 rounds â‡’ level overlay.  Five levels total.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* ===== CONFIG ===== */
const BE_ROUNDS   = 10;                         // 10 hostiles per level
const BE_TIME_MS  = [20_000, 15_000, 10_000, 5_000]; // level limits
const BE_LEVELS   = BE_TIME_MS.length;          // = 4


/* ===== STATE ===== */
let beLevel     = 1;
let beRound     = 0;
let beLevelScore = 0;       // NEW â€“ resets every level
let beTotalScore = 0;       // NEW â€“ accumulates across all levels
let beTarget    = null;
let beTimerMs   = BE_TIME_MS[0];        // 20 000 ms for Level 1
let beTimeoutId = null;
let beTickerId  = null;
let beStartT    = null;
let beSumT      = 0;           // cumulative reaction time this level
let beActive    = false;       // â‡ true only when we are listening for hits
const beHistory = [];          // store {level, hits, avg} for summary

/* helper: build exactly ten hostiles all inside current radar cover */
function rebuildBullseyeTracks () {
  // keep friendlies / TBMs if any, remove old hostiles
  tracks = tracks.filter(t => t.friendly || t.isTbm || t.isCruise);

  while (tracks.filter(t => !t.friendly && !t.destroyed).length < 10) {
    const h = spawnVisibleHostile();        // helper from earlier patch
    if (!h) break;                          // safety
  }
}

const beAvgs    = [];          // avg time per level (for improvement)

/* ===== DOM ===== */
const timerEl   = document.getElementById('timerDisplay');

const menuBtn   = document.getElementById('btnBullseye'); // existing button

/* â”€â”€â”€ FULL-RESET FOR RADARS + LAUNCHERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function resetLaunchersAndRadars () {
  statics.forEach(s => {
    /* Patriot & TPS-75 radars */
    if (s.type === 'rad' || s.type === 'c2Rad') {
      s.disabledUntil = 0;          // back to green
      s.animFrom = s.animTo = null; // cancel any wedge animation
    }

    /* NASAMS launcher */
    if (s.id === 'NASAMS') {
      NASAMSMissiles      = 18;
      NASAMSDisabledUntil = 0;
    }

    /* Patriot FUs */
    if (s.type === 'fu' && s.id !== 'NASAMS') {
      s.ammo = { pac2:12, pac3:16, mse:24 }; // full load-out
      s.engagementsRemaining = 28;           // 2 rounds = 14 shots
      s.disabledUntilFu      = 0;            // clear reload timer
    }
  });
}

/* 1) one global timestamp â€“ null while TPS-75 is up */
let tpsDownStart = null;

/* --------------------------------------------------------- */
function beginBeLevel () {
    beLevelScore = 0;        // â† reset this levelâ€™s score
  updateScoreDisplay();    // so the UI shows â€œ0/10â€
  
  beRound   = 0;
  beSumT    = 0;
  beTimerMs = BE_TIME_MS[beLevel - 1];      // 20â†’15â†’10â†’5
  beActive  = true;                              /* enable hit-test */
  rebuildBullseyeTracks();                  /* new set of ten */
  timerEl.textContent = (beTimerMs/1000).toFixed(1)+' s';
  nextBeRound();
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Ensure the prompt is ONLY for tracks currently detectable
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* helper: spawn hostiles until at least one is immediately visible */
function spawnVisibleHostile() {
  let tries = 0;
  while (tries < 40) {                     // safety cap
    const t = newTrack();                  // random hostile
    tracks.push(t);
    updateVisibility();                    // refresh _visible flags
    if (isTrackVisible(t)) return t;       // good â€“ we can use it
    tries++;
  }
  return null;                             // fallback (shouldnâ€™t happen)
}

/* replacement for the old nextBeRound() */
function nextBeRound () {
  clearTimeout(beTimeoutId);
  clearInterval(beTickerId);

  // Level finished?
  if (beRound >= BE_ROUNDS) {
    beActive = false;            /* disable hit-test until next level */
    finishBeLevel();
    return;
  }

  /* ----- pick a target that is visible RIGHT NOW ----- */
  updateVisibility();   // make sure _visible flags are current

  let candidates = tracks.filter(t =>
    !t.friendly && !t.destroyed && isTrackVisible(t)
  );

  // If none are visible, spawn until we get one
  if (!candidates.length) {
    const visT = spawnVisibleHostile();
    if (visT) candidates = [visT];
    else {   // catastrophic fall-back: just skip this round
      onBeTimeout();
      return;
    }
  }

  beTarget = candidates[Math.floor(Math.random() * candidates.length)];

  // Announce
  statusEl.textContent = `Select Group Bullseye ${formatBE(beTarget)}`;
  beRound++;

  // Start timers
  beStartT    = Date.now();
  beTickerId  = setInterval(updateBeClock, 100);
  beTimeoutId = setTimeout(onBeTimeout, beTimerMs);
}


function updateBeClock() {
  // only show a timer during Bullseye practice
  if (mode === 'free') {
    const left = Math.max(0, beTimerMs - (Date.now() - beStartT));
    timerEl.textContent = (left/1000).toFixed(1) + 'â€¯s';
  } else {
    // no timer in Airâ€‘Battle
    timerEl.textContent = '';
  }}


function onBeSuccess () {
  clearTimeout(beTimeoutId);
  clearInterval(beTickerId);
  const rt = Date.now() - beStartT;
  beSumT  += rt;
  beLevelScore += 1;
  updateScoreDisplay();
  feedbackEl.textContent = `+1  (${(rt/1000).toFixed(2)} s)`;
  nextBeRound();
}

function onBeTimeout () {
  clearInterval(beTickerId);
  beLevelScore -= 1;
  updateScoreDisplay();   
  feedbackEl.textContent = '-1  (Timed out)';
  nextBeRound();
}

function finishBeLevel () {
  /// store average RT
 const avg = beSumT / BE_ROUNDS;
  beAvgs.push(avg);
  beHistory.push({ level: beLevel, hits: beLevelScore, avg });

  // accumulate into the grand total
  beTotalScore += beLevelScore;

  // build overlay
  const ov = document.createElement('div');
  ov.className = 'overlay';
  // still show _this levelâ€™s_ score out of 10
  ov.innerHTML = `
    <div class="overlayBox">
      <h2>Level ${beLevel} Complete</h2>
      <p>Score: <strong>${beLevelScore}/${BE_ROUNDS}</strong></p>
      <p>Avg reaction: ${(avg/1000).toFixed(2)} s</p>
      <button id="beNext">
        ${beLevel < BE_LEVELS ? 'Next Level Â»' : 'Show Summary'}
      </button>
    </div>`;
  document.body.appendChild(ov);

  // wire up button
  ov.querySelector('#beNext').onclick = () => {
    ov.remove();
    if (beLevel < BE_LEVELS) {
      beLevel++;
      beActive = true;          /* re-enable hit-test for new level */
      beginBeLevel();
    } else {
      showBeSummary();
    }
  };
}

function showBeSummary () {
    beActive = false;

  /* Build a very small performance chart on the game canvas */
  const chartH = 60, chartW = 180, pad = 8;
  const maxT   = Math.max(...beHistory.map(o => o.avg));
  ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,chartW+pad*2,chartH+pad*2);
    ctx.translate(pad, pad);
    ctx.strokeStyle = '#0ea5e9';
    ctx.lineWidth = 2;
    ctx.beginPath();
    beHistory.forEach((o,i)=>{
      const x = (i/(BE_LEVELS-1))*chartW;
      const y = chartH - (o.avg / maxT)*chartH;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = '10px monospace';
    beHistory.forEach((o,i)=>{
      const x = (i/(BE_LEVELS-1))*chartW;
      const y = chartH + 12;
      ctx.fillText(`L${o.level}`, x-6, y);
    });
  ctx.restore();

  let improvement = 0;
  const lines = beAvgs.map((a,i)=>{
    if(i){ improvement += beAvgs[i-1]-a; }
    return `L${i+1}: ${(a/1000).toFixed(2)} s`;
  }).join('<br>');

  const ov = document.createElement('div');
  ov.className = 'overlay';
  ov.innerHTML = `
    <div class="overlayBox">
      <h2>Timed Practice Summary</h2>
      <canvas id="beReactionChart" width="200" height="200"
              style="border:1px solid #444; margin-bottom:.5rem;"></canvas>
      <p>Total score: <strong>${beTotalScore}/${BE_ROUNDS*BE_LEVELS}</strong></p>
      ${lines.replace(/<br>/g,'<br>')}
      <p><em>Overall improvement: ${(improvement/1000).toFixed(2)}â€¯s</em></p>
      <button id="beClose">Close</button>
    </div>`;
  document.body.appendChild(ov);
  ov.querySelector('#beClose').onclick = () => ov.remove();

  // â€” draw the reactionâ€‘time line in red â€”
  const chart = ov.querySelector('#beReactionChart');
  const ctx2  = chart.getContext('2d');
  const dataS = beAvgs.map(a => a/1000);         // convert to seconds
  const maxY  = Math.max(...dataS) * 1.1;        // a little headroom
  const w     = chart.width,  h = chart.height;
  ctx2.clearRect(0,0,w,h);
  ctx2.beginPath();
  dataS.forEach((val, i) => {
    const x = (i / (dataS.length - 1)) * (w - 20) + 10;
    const y = h - ((val / maxY) * (h - 20)) - 10;
    if (i === 0) ctx2.moveTo(x,y);
    else         ctx2.lineTo(x,y);
  });
  ctx2.strokeStyle = 'red';
  ctx2.lineWidth   = 2;
  ctx2.stroke();

  // draw small dots
  dataS.forEach((val, i) => {
    const x = (i / (dataS.length - 1)) * (w - 20) + 10;
    const y = h - ((val / maxY) * (h - 20)) - 10;
    ctx2.beginPath();
    ctx2.arc(x,y,3,0,Math.PI*2);
    ctx2.fillStyle = 'red';
    ctx2.fill();
  });
}

/* ---------------------------------------------------------
   HOOK INTO THE NORMAL POINTER-SELECTION ROUTINE
   (Add this once near the end of your pointerup / click logic)
--------------------------------------------------------- */
function checkBeSelection () {
    if (!beActive || mode !== 'free' || !beTarget || !selectedTrack) return;
  if (selectedTrack === beTarget) onBeSuccess();
}
window.addEventListener('pointerup', checkBeSelection);



function startBullseyePractice() {
  mode          = 'free';
  beLevelScore  = 0;      // reset the Bullseye score
  beTotalScore  = 0;      // if you want to track total over levels
  // â€¦rest unchangedâ€¦
  updateScoreDisplay();
  beginBeLevel();
}

/* ---------------------------------------------------------
   WIRE THE OVERLAY MENU BUTTON
   (replace the old handler for btnBullseye)
--------------------------------------------------------- */
btnBullseye.onclick = () => {
  modeSelect.style.display = 'none';
  startBullseyePractice();
};

  /* â€”â€”â€”â€”â€” Skip-button label toggler â€”â€”â€”â€”â€” */
function refreshSkipBtn() {
  if (mode === 'free') {               // Bullseye practice
    skipBtn.textContent   = 'Fight Air Battle';
    skipBtn.dataset.action = 'practice';
  } else {                             // Air-battle levels
    skipBtn.textContent   = 'Next LevelÂ»';
    skipBtn.dataset.action = 'next';
  }
}

  // *** 4) Airâ€‘Battle = your existing Practiceâ€‘mode logic ***
  function startPracticeMode() {
    mode = 'practice';
    round = 0; score = 0;     // reset score
    timerEl.textContent = '';      // â† ADD THIS LINE
    fitMobileView();          // keep mobile tap alignment perfect
    // you can either call nextQueueTrack() directly...
    nextQueueTrack();
    // â€¦or just invoke your old button handler:
    // document.getElementById('practiceBtn').click();
    onGameStart();
    refreshSkipBtn();          // â† update label / action
  

  // one initial call so the button is correct on page-load
 refreshSkipBtn();
  }
  // *** 5) Wire up the overlays ***
  ackBtn.addEventListener('click', () => {
    disclaimer.style.display = 'none';
    modeSelect.style.display = 'flex';
  });

btnAir.addEventListener('click', () => {
  modeSelect.style.display = 'none';
  startPracticeMode();
});

  btnAir.addEventListener('click', () => {
    modeSelect.style.display = 'none';
    startPracticeMode();
  });
// immediately advance to the next level, tearing down & rebuilding
function goNextLevel() {
  paused = false;       // unâ€‘freeze the game loop
  level++;              // bump the level counter
  setupLevel(level);    // full rebuild for that level
}
skipBtn.addEventListener('click', goNextLevel);



    // â”€â”€â”€ CONFIG & STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const CFG = {
      trackCount: 10,
      nmPerPixel: 0.2,
      maxSpawnNm: 150,
      frameRate: 60,
      maxSpeedKts: 800,
      destroyMs: 6000,
      autoKillMs: 10000,
      rounds: 10,
      tbmCount:      3,
  tbmMinDistNm:  5,
  tbmMaxDistNm:  10,
  tbmAltitude:   999,
  tbmSpeedKts:   3400,
  tbmWindowMs:   null,    // will be set per wave

    };

    let tbmWaves = [];        // active TBM waves

    let worldWidth, worldHeight;
    let bullseye, statics = [], tracks = [];
    let mouse = { wx:0, wy:0, sx:0, sy:0, px:0, py:0 },
        dragStart = null, isDragging = false, rubber = null,
        scale = 1, offX = 0, offY = 0;
    let pinch = { active:false, startDist:0, startScale:1, center:{x:0,y:0} };
    let selectedTrack = null, selectedStatic = null;
    let selectedTrack2 = null, selectedStatic2 = null;
    let mode='free', phase='', curTrack=null, killTimer=null;
    let round=0, score=0;
 
    let shiftDown = false;
window.addEventListener('keydown', e => { if (e.key === 'Shift') shiftDown = true; });
window.addEventListener('keyup',   e => { if (e.key === 'Shift') shiftDown = false; });


// â”€â”€â”€ TAG MODES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let tagMode   = 0,
    tagLabels = ['OFF','B/E','JTN','INFO','ALL','ALT']; 

    let compassOn = false;
let level = 1;
let speedMultiplier = 1;  // 1.0Ã— on Level 1, 1.5Ã— on Level 2, etc.
let coverTimer = null, practiceSaveIndex = null;

// NASAMS state
let NASAMSMissiles      = 18;
let NASAMSDisabledUntil = 0;

//PATRIOT Reorient
let pendingReorient  = false;
    let pendingStatic    = null;

    //PATRIOT down
    // â”€â”€â”€ track when we last forced a radar failure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastRadFailure = 0;
let nextOutageAllowed = 0;  // timestamp (ms) after which we may schedule another outage

let pendingEngagements = [];

//missile

let missiles = [];   // track all inâ€‘flight missile dots
// alongside your `missiles = []`:
let bombs = [];

// â€” right after you grab your DOM refs â€” 
const quadrantStates = {
  NW: false,
  NE: false,
  SW: false,
  SE: false
};


// helper to reâ€‘paint one button:
function updateQuadrantButton(q) {
  const btn = redwoodMenu.querySelector(`button[data-q="${q}"]`);
  if (!btn) return;
  btn.classList.toggle('hot',  quadrantStates[q]);
  btn.classList.toggle('cold', !quadrantStates[q]);
}

// collapse menu only if _all_ are cold:
function collapseIfAllCold() {
  if (!Object.values(quadrantStates).some(v => v)) {
    redwoodWrap.classList.remove('open');
  }
}

// jump immediately to the next level
function goNextLevel() {
  paused = false;      // resume the physics loop
  level++;             // bump the level counter
  setupLevel(level);   // full rebuild for that level
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   REDWOOD  â€“ single source of truth
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const redwoodBtn  = document.getElementById('redwoodBtn');
const redwoodWrap = document.getElementById('redwoodWrap');
const redwoodMenu = document.getElementById('redwoodMenu');

redwoodBtn.addEventListener('click', () => {
  console.log('ğŸ”´ Redwood button clicked');
  redwoodWrap.classList.toggle('open');
});


/* state flags */
let redwoodOpen     = false;
let redwoodActive   = false;
let redwoodQuadrant = null;
let redwoodTimerId  = null;

/* master toggle (button click) */
function toggleRedwoodMenu () {
  redwoodOpen = !redwoodOpen;
  redwoodWrap.classList.toggle('open', redwoodOpen);
}
redwoodBtn.addEventListener('click', toggleRedwoodMenu);

/* turn COLD / HOT just manipulate button colour */
function setRedwoodHot(q) {
  redwoodActive     = true;
  redwoodQuadrant   = q;
  quadrantStates[q] = true;
  updateQuadrantButton(q);
}

function setRedwoodCold(q) {
  quadrantStates[q] = false;
  updateQuadrantButton(q);
  collapseIfAllCold();
}


/* â€” the rest of your existing HOT-assessment logic stays the same â€” */

redwoodMenu.querySelectorAll('button').forEach(btn => {
  btn.addEventListener('click', () => {
    const q = btn.dataset.q;
    statusEl.textContent = `SL, ADAFCO, Request REDWOOD HOT ${q} Quadrant`;
    setTimeout(() => initialAssess(q), 2000);
  });
});


/* call on level reset / game reset */
function resetRedwood () {
  clearInterval(redwoodTimerId);
  Object.keys(quadrantStates).forEach(q => {
    quadrantStates[q] = false;
    updateQuadrantButton(q);
  });
  redwoodActive   = false;
  redwoodQuadrant = null;
  redwoodWrap.classList.remove('open');
}
/* â”€â”€â”€ dynamic pick radius based on zoom â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function getPickRadiusPx() {
  // visible NM across the canvas right now
  const visibleNm = canvas.width * CFG.nmPerPixel;   // â¬… uses your globals
  let r = 12;      // â† your current click cloud in pixels â”€ adjust if needed
  if (visibleNm <= 100) r *= 2;   // zoomed-in: double
  if (visibleNm <=  50) r *= 3;   // super-tight: triple
  if (visibleNm <=  40) r *= 3.5;   // new: super-close zoom
  if (visibleNm <=  30) r *= 4;   // new: super-close zoom
  return r;
}
// dynamic tap radius (in *screen* pixels)
function dynamicClickRadius() {
  const visibleNm = canvas.width * CFG.nmPerPixel / scale;   // current view-width
  let r = CLICK_RADIUS_SCREEN;          // 15 px baseline
  if (visibleNm <= 100) r *= 2;         // zoom-in â‰¤100 NM  â†’ double
  if (visibleNm <=  50) r *= 3;         // super-tight â‰¤50 NM â†’ triple
  if (visibleNm <=  40) r *= 3.5;   // new: super-close zoom
  if (visibleNm <=  30) r *= 4;   // new: super-close zoom
  return r;
}


/**
 * Returns true if object o lies in quadrant q (one of "NW","NE","SW","SE")
 */
function inQuadrant(o, q) {
  const dx = o.x - bullseye.x;
  const dy = o.y - bullseye.y;
  switch (q) {
    case 'NW': return dx < 0 && dy < 0;
    case 'NE': return dx > 0 && dy < 0;
    case 'SW': return dx < 0 && dy > 0;
    case 'SE': return dx > 0 && dy > 0;
  }
  return false;
}

// 2s assessment
function initialAssess(q) {
  if (checkHotCondition(q)) {
    statusEl.textContent = `ADAFCO, SL, REDWOOD HOT Approved ${q} Quadrant`;
    setRedwoodHot(q);
    redwoodTimerId = setInterval(() => reAssess(q), 1 * 60 * 1000);
  } else {
    statusEl.textContent = `ADAFCO, SL, REDWOOD HOT Denied ${q} Quadrant`;
    setRedwoodCold(q);
  }
}

// 5â€‘minute reassess
function reAssess(q) {
  if (!checkHotCondition(q)) {
    clearInterval(redwoodTimerId);
    statusEl.textContent = `ADAFCO, SL, REDWOOD COLD ${q} Quadrant`;
    setRedwoodCold(q);
  }
}

// >5 hostiles && NMT1 friendly
function checkHotCondition(q) {
  // count the living hostiles in quadrant q
  const hostiles = tracks.filter(t =>
    !t.destroyed &&
    !t.friendly &&
    inQuadrant(t, q)
  ).length;

  // count the living friendlies in quadrant q
  const friendlyCount = tracks.filter(t =>
    !t.destroyed &&
    t.friendly &&
    inQuadrant(t, q)
  ).length;

  // now require â‰¥10 hostiles and â‰¤1 friendly
  return hostiles >= 7 && friendlyCount <= 1;
}


// suppress ROE penalty inside HOT quadrant
function roePenaltyAllowed(track) {
  return !(redwoodActive && inQuadrant(track, redwoodQuadrant));
}

function showLogsOverlay(parent) {
  parent.style.display = 'none';               // hide the menu

  const ov = document.createElement('div');
  ov.className = 'overlay';
  ov.innerHTML = `
    <div class="overlayBox" style="max-width:600px; max-height:80vh; overflow:auto;">
      <h2>Mission Logs</h2>
      <pre style="text-align:left; font-family:monospace;"
           id="missionLogPre"></pre>
      <button id="closeLogs">Close</button>
    </div>`;
  document.body.appendChild(ov);

  // dump the log
  const pre  = ov.querySelector('#missionLogPre');
  pre.textContent = MISSION_LOG
    .map(o => `[${o.z}] ${o.msg}`)
    .join('\n');

  ov.querySelector('#closeLogs').onclick = () => {
    ov.remove();
    parent.style.display = 'flex';             // bring the menu back
  };
}

/**
 * Build `numGroups` of hostile tracks whose sizes sum to `totalHostiles`.
 * Each group is a tight cluster (â‰¤3â€¯NM apart).
 */
 function newHostileGroups(numGroups, totalHostiles) {
  // 1) start each group at sizeÂ 1
  const sizes = Array(numGroups).fill(1);
  let rem = totalHostiles - numGroups;
  // 2) randomly bump groups up to 4 until weâ€™ve allocated all extras
  while (rem > 0) {
    const i = Math.floor(Math.random() * numGroups);
    if (sizes[i] < 4) {
      sizes[i]++;
      rem--;
    }
  }

  // 3) build the actual tracks
  const hostiles = [];
  sizes.forEach(size => {
    // 3a) one â€œcenterâ€ track
    const center = newTrack();
    hostiles.push(center);

    // 3b) the other (size-1) members, 1â€“3Â NM from center
    for (let j = 1; j < size; j++) {
      const member = newTrack();
      const ang  = Math.random() * 2 * Math.PI;
      const dist = (1 + Math.random() * 2) / CFG.nmPerPixel;  // worldâ€‘px
      member.x = center.x + Math.cos(ang) * dist;
      member.y = center.y + Math.sin(ang) * dist;
      member.id = ('00000' + rand(1000, 7776)).slice(-5);
      hostiles.push(member);
    }
  });

  return hostiles;
}

// helper â€“ cancel every shot currently aimed at a track, after a 5â€¯min delay
function abortTrack(t) {
  // Schedule the abort logic to run in 5 minutes
  setTimeout(() => {
    // 1) cancel any scheduled intercept timer
    if (t.mslTimer) {
      clearTimeout(t.mslTimer);
      t.mslTimer = null;
    }
    // 2) remove any inâ€‘flight missiles targeting this track
    missiles = missiles.filter(m => m.target !== t);
    // 3) revert the tag to ENGAGE so it can be re-shot later
    t.tag     = 'ENGAGE';
    t.tagTime = Date.now();
  }, 5 * 1000);  // 5â€¯secâ€¯ms
}

// alias if youâ€™re calling `abort()` elsewhere
const abort = abortTrack;



/**
 * Returns `true` if the shot should be blocked by NASAMSâ€weaponsâ€red,
 * or `false` if you should proceed with the W handler.
 * Sideâ€‘effects: decrements missile count and schedules reload.
 */
 function checkNASAMSStatus(isInsideCircle) {
  const now = Date.now();

  // 1) If weâ€™re still in a reload interval, block and show ETIC
  if (now < NASAMSDisabledUntil) {
    const mins = Math.ceil((NASAMSDisabledUntil - now) / 60000);
    const msg  = `ADAFCO, TD, NASAMS reload ETIC ${mins}â€¯min`;
    statusEl.textContent   = msg;
    feedbackEl.textContent = msg;
    return true;
  }

    // 2) If fewer than 2 remain, start a 15â€¯min reload now
  if (NASAMSMissiles <= 1) {
    NASAMSDisabledUntil = now + 15 * 60 * 1000;
    const mins = Math.ceil((NASAMSDisabledUntil - now) / 60000);
    const msg  = `ADAFCO, TD, NASAMS reload ETIC ${mins}â€¯min`;
    statusEl.textContent   = msg;
    feedbackEl.textContent = msg;
    setTimeout(() => { NASAMSMissiles = 18; }, 15 * 60 * 1000);
    return true;
  }

    // 3) Otherwise (valid ring shot), consume two AIMâ€‘120s
  if (isInsideCircle) {
    NASAMSMissiles -= 2;
  }

  return false;
}

// â”€â”€â”€ altitude â†’ detection range mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getDetectionRange(alt) {
  if (alt < 50)   return 60;
  if (alt < 100)  return 70;
  if (alt < 200)  return 100;
  if (alt < 300)  return 140;
  return 180;
}


    // â”€â”€â”€ SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const canvas     = document.getElementById('scope'),
          ctx        = canvas.getContext('2d'),
          statusEl   = document.getElementById('status'),
          feedbackEl = document.getElementById('feedback'),
          tagsBtn    = document.getElementById('tagsBtn'),
          compassBtn = document.getElementById('compassBtn'),
          helpOverlay= document.getElementById('helpOverlay');
    const label      = document.getElementById('cursorLabel');
function handleInternalZoom(e) {
  // e.deltaY (desktop) or e.scale (mobile) â†’ decide scale factor
  let zoomFactor = 1;
  if (typeof e.deltaY === 'number') {
    // wheel on desktop: zoom in/out by 10%
    zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  } else if (typeof e.scale === 'number') {
    // pinch on iOS: use the gestureâ€™s scale directly
    zoomFactor = e.scale;
      applyZoomTransform();   // <- you already have this
  updateUiScale();        // <- add this line
  }

  // you need to zoom _around_ the pointer position so it feels natural:
  // 1) figure out canvasâ€local coords of the event
  const rect = canvas.getBoundingClientRect();
  const cx   = (e.clientX - rect.left);
  const cy   = (e.clientY - rect.top);

  // 2) convert to world coords before zoom
  const worldX = offX + cx / scale;
  const worldY = offY + cy / scale;

  // 3) apply zoom
  const oldScale = scale;
  scale *= zoomFactor;

  // 4) re-center so that the point under the finger/mouse stays fixed
  offX = worldX - cx / scale;
  offY = worldY - cy / scale;
}
function applyZoomTransform() {
  const m = `matrix(${scale},0,0,${scale},${-offX*scale},${-offY*scale})`;
  document.getElementById('returnLayer').style.transform = m;
  document.getElementById('cardLayer'  ).style.transform = m;
}


//  â€” Prevent native page-zoom on Ctrl+wheel (desktop) â€”
window.addEventListener('wheel', e => {
  if (e.ctrlKey) {
    e.preventDefault();
     // â€¦but leave e.deltaY available for your internal zoom logicâ€¦
    handleInternalZoom(e);
    // re-sync card-scale on mouseâ€“wheel zoom too:
    updateUiScale();
  }
}, { passive: false });

//  â€” Prevent native browser pinch/gesture (iOS Safari) â€”
canvas.addEventListener('gesturestart', e => e.preventDefault());
canvas.addEventListener('gesturechange', e => {
  e.preventDefault();
  handleInternalZoom(e);
});
canvas.addEventListener('gestureend', e => e.preventDefault());

// 1) call this after you update `scale`, `offX`, and `offY`
function updateUiScale() {
  const worldPx = canvas.width  / scale;
  const visibleNm = worldPx * CFG.nmPerPixel;
  const refNm     = canvas.width * CFG.nmPerPixel;
  const sizeFactor = refNm / visibleNm;

  document.getElementById('uiLayer')
          .style.setProperty('--card-scale', sizeFactor);
}

    // â”€â”€â”€ CONFIG & STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fireKey(k){
  window.dispatchEvent(new KeyboardEvent('keydown',{ key: k }));
}
// â”€â”€â”€ speech-queue setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let micActive    = false;
const speechQueue = [];

// only override if the API exists
if (window.speechSynthesis && typeof speechSynthesis.speak === 'function') {
  // keep a reference to the original
  const _origSpeak = speechSynthesis.speak.bind(speechSynthesis);

  // install our wrapper
  speechSynthesis.speak = utterance => {
    try {
      if (micActive) {
        // queue it for later
        speechQueue.push(utterance);
      } else {
        // speak immediately
        _origSpeak(utterance);
      }
    } catch (err) {
      console.error('speechSynthesis override failed:', err);
      // fallback so nothing ever stops your game
      _origSpeak(utterance);
    }
  };
}

//////////////////////////////////////////////////////////////////
/////////////////ALL VOICE CODE SECTION ///////////////////////////
//////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////


// Global AudioContext, used to unlock mobile audio
let _audioCtx = null;

function unlockMobileAudio() {
  if (_audioCtx) return;
  try {
    _audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // a zero-length buffer to kick things off
    const src = _audioCtx.createBufferSource();
    src.buffer = _audioCtx.createBuffer(1, 1, 22050);
    src.connect(_audioCtx.destination);
    src.start(0);
  } catch (e) {
    console.warn('AudioContext unlock failed:', e);
  }
}
/******************************************************************
 * speakBE(bearing, range)
 *   bearing â€“ integer 0-360   â†’  "zero two five"
 *   range   â€“ integer 0-999   â†’  normal english words
 ******************************************************************/
const digitWord = ['zero','one','two','three','four','five','six','seven','eight','nine'];

function speakBE(bearing, range) {
  // 1) bearing: 3 digits, always zero-padded â†’ words
  const brgStr = ('000' + (bearing % 360 || 360)).slice(-3);   // 000â†’360
  const brgW   = brgStr.split('').map(d => digitWord[+d]).join(' ');

  // 2) range: use speech-friendly cardinal words
  const rangeW = new Intl.NumberFormat('en', { notation:'standard' })
                    .format(range)
                    .replace(/,/g,'')               // strip thousands comma
                    .split(' ')                     // "one hundred twenty"
                    .join('-');                     //   â†’ one-hundred-twenty

  return `${brgW} ${rangeW}`;
}


let lastRadioLine = '';

/* â€”â€”â€” QUICK helper: triggers the Fireball button â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
function fireballVoice(txt){
  if(!txt.includes('fireball')) return false;   // didnâ€™t fire
  fireballBtn.click();                          // press the button
  return true;                                  // handled
}

/* â€”â€”â€” Normalise common mis-hears before the main handlers â€”â€”â€”â€” */
function normaliseBullseye(str){
  return str
    .replace(/\bboth side\b/gi,  'bullseye')
    .replace(/\bbull side\b/gi,  'bullseye')
    .replace(/\bbulls eye\b/gi,  'bullseye')
    // group homophones
    .replace(/\bgrew(p|ve)?\b/gi, 'group');
}

// at top of your script
function speakRedwood(text) {
  const u = new SpeechSynthesisUtterance(text);
  u.rate = 1.2;           // slower than your default 1.9
  u.lang = 'en-US';
  speechSynthesis.speak(u);
}

/* â”€â”€â”€ SPOKEN WORDS â†’ 2-letter quadrant codes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const spokenToQuad = {
  'north west': 'NW',  'northwest': 'NW',  'nw': 'NW',
  'north east': 'NE',  'northeast': 'NE',  'ne': 'NE',
  'south west': 'SW',  'southwest': 'SW',  'sw': 'SW',
  'south east': 'SE',  'southeast': 'SE',  'se': 'SE'
};

/* â”€â”€â”€ Better TTS fixer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â€¢ SL      â†’ â€œS Lâ€
   â€¢ ADAFCO  â†’ â€œah-daf-kohâ€
   â€¢ NE/NW/SE/SW (word-level) â†’ full words                        */
function ttsFix(line){
  // 1) callsigns
  line = line
    .replace(/\bSL\b/gi,        'S L')
    .replace(/ADAFCO/gi,        'ah-daf-koh');

  // 2) quadrant codes
  const quadMap = {
    'NE':'North East',  'NW':'North West',
    'SE':'South East',  'SW':'South West'
  };
  line = line.replace(/\b(N[EW]|S[EW])\b/gi,
    m => quadMap[m.toUpperCase()]              // map â€œSWâ€ â†’ â€œSouth Westâ€
  );

  return line;
}


/**
 * Detects â€œredwood hot â€¦â€ in a transcript, presses the button,
 * then speaks whichever APPROVED / DENIED line SL puts in statusEl.
 * Returns true if it handled the utterance, false otherwise.
 */
function handleRedwoodHotVoice(txt){
  const m = txt.match(/redwood\s+hot\s+([\w\s]+)/i);
  if(!m) return false;                          // phrase not present

  /* resolve quadrant from spoken words */
  const words = m[1].trim().toLowerCase();
  const key   = Object.keys(spokenToQuad)
                       .find(k => words.includes(k));
  if(!key) return false;                        // none matched
  const q     = spokenToQuad[key];              // "NW", "NE", ...

  /* open menu and press the normal button */
  redwoodWrap.classList.add('open');
  const btn = redwoodMenu.querySelector(`button[data-q="${q}"]`);
  if(btn) btn.click();

  /* speak SLâ€™s response (Approved / Denied) once it appears */
  const once = new MutationObserver(() => {
    const resp = statusEl.textContent.trim();
    if(/approved|denied/i.test(resp)){
      once.disconnect();
      // use your new slower voice for Redwood
      speakRedwood( ttsFix(resp) );
    }
  });
  once.observe(statusEl,{childList:true,characterData:true,subtree:true});

  return true;
}
/* word-digits â†’ real digits (0-9) */
const wordDigit = {
  zero:'0', oh:'0', one:'1', two:'2', three:'3', four:'4', five:'5',
  six:'6', seven:'7', eight:'8', nine:'9'
};

/* collapse words+digits into one 5-digit string (â€œone two three four fiveâ€ â†’ "12345") */
function extractFiveDigits(arr){
  const out = [];
  arr.forEach(w=>{
    if(/^\d$/.test(w))              out.push(w);           // literal â€œ5â€
    else if(wordDigit[w]!==undefined) out.push(wordDigit[w]); // â€œfiveâ€
  });
  return out.length===5 ? out.join('') : null;
}
/**
 * Smoothly swing the selected radarâ€™s wedge
 * from its current wedgeDir to `newBearing`.
 */
function animateRadarSwing(radar, newBearing) {
  radar.animFrom  = radar.wedgeDir;
  radar.wedgeDir  = newBearing;
  radar.animStart = Date.now();
}


/**
 * Voice-driven PTL (â€œre-orient â€¦ radar â€¦ <bearing>â€)
 * â€“ understands quadrant words OR explicit Patriot JTN
 * â€“ arms O-key flow, fires a synthetic click 50 NM from BULLSEYE
 */
function handleReorientVoice(raw) {
  const txt = raw.toLowerCase();

  /* 0 â€” must contain a trigger word */
  if (!/(re[- ]?orient|ptl|radar|target(?:ing)? line)/.test(txt)) return false;

  /* 1 â€” quadrant */
  const quadRe = {
    NW: /\b(?:north\s*west|northwest|nw)\b/,
    NE: /\b(?:north\s*east|northeast|ne)\b/,
    SW: /\b(?:south\s*west|southwest|sw)\b/,
    SE: /\b(?:south\s*east|southeast|se)\b/,
  };
  let quad = null;
  for (const [k, re] of Object.entries(quadRe)) if (re.test(txt)) { quad = k; break; }
  if (!quad) return false;

  /* 2 â€” which radar */
  const quadrantMap = { NW:'00173', SW:'00171', SE:'00172', NE:'00170' };
  const idMatch = txt.match(/\b0*?(00173|00171|00172|00170)\b/);
  const radarId = idMatch ? idMatch[1] : quadrantMap[quad];
  const radar   = statics.find(s => s.type === 'rad' && s.id.endsWith(radarId));
  if (!radar) return false;

  /* 3 â€” bearing: first 3 digits after we scrub the JTN */
  const scrubbed = txt.replace(radarId, '');         // strip the digits that belong to the JTN
  const digits   = (scrubbed.match(/\d/g) || []).slice(0, 3).join('');
  if (digits.length < 3) return false;
  const bearingCmd = (+digits || 360);               // 000 â†’ 360Â°

  /* 4 â€” arm the normal O-key flow */
  selectedStatic  = radar;
  pendingReorient = true;
  pendingStatic   = radar;
  statusEl.textContent   = `Tap on the scope to orient Launcher ${radar.id}`;
  feedbackEl.textContent = '';

  /* 5 â€” synthetic click 50 NM from BULLSEYE (fix) */
  const rangeNm = 100000000;
  const px      = rangeNm / CFG.nmPerPixel;
  const rad     = bearingCmd * Math.PI / 180;        // 0Â° =N, 90Â° =E
  const clickX  = bullseye.x + Math.sin(rad) * px;
  const clickY  = bullseye.y - Math.cos(rad) * px;

  const scope   = document.getElementById('scope');
  const rect    = scope.getBoundingClientRect();
  const clientX = rect.left + clickX;
  const clientY = rect.top  + clickY;

  ['pointerdown', 'pointerup', 'click'].forEach(type =>
    scope.dispatchEvent(new PointerEvent(type, {
      pointerType: 'mouse', bubbles: true, cancelable: true,
      clientX, clientY,
    }))
  );

  /* 6 â€” voice feedback */
  radioSay(`${ADAFCO}, ${ICC}, Setting Patriot Target Line ${String(bearingCmd).padStart(3,'0')} degrees.`);
  return true;
}






/* bearing/ range helpers */
function bearing(a,b){ return (Math.atan2(b.x-a.x,a.y-b.y)*180/Math.PI+360)%360;}
function distNm(a,b){ return Math.round(Math.hypot(a.x-b.x,a.y-b.y)*CFG.nmPerPixel);}
function angDiff(a,b){ return Math.min(Math.abs(a-b),360-Math.abs(a-b));}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ENGAGE  âœ§  â€œGuardian Bigfoot Engage Group Bullseye 12345 â€¦â€
   â€¢ first 3 digits  â†’ bearing  (001-360Â°)
   â€¢ last  2 digits  â†’ range NM
   â€¢ hits every hostile or cruise-missile within Â±3Â° & Â±5 NM
   â€¢ launches exactly 1 pair per contact via your engageTrack(t)
   â€¢ speaks â€œbirds away â€¦ n contactsâ€ (or negate if none)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/

/* simple bearing & distance utilities (independent) */
function brg(b,a){                  // bearing Â° aâ†’b
  return (Math.atan2(b.x-a.x,a.y-b.y)*180/Math.PI+360)%360;
}
function rng(b,a){                  // distance NM aâ†”b  (needs CFG.nmPerPixel)
  return Math.round(Math.hypot(b.x-a.x,b.y-a.y)*CFG.nmPerPixel);
}

/* â”€â”€â”€ cover / engage GROUP BULLSEYE (5- or 6-digit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Guardian Bigfoot cover|engage group [bullseye] 12345 / 123456
   â€¢ first 3 digits  = bearing   (001â€“360 â†’ map 000 â†’ 360)
   â€¢ last  2â€“3 digits = range NM
   â€¢ gate Â±3Â° / Â±5 NM
   â€¢ obeys coverage â†’ birds affirm / birds negate
------------------------------------------------------------------------ */
function groupBullseyeVoice(raw){
  /* â”€â”€ one regex: â€œgroup â€¦ <number>â€ (bullseye word is optional) â”€â”€ */
  const m = raw.match(
  /\bguardian\b[\s,]*\bbigfoot\b[\s,]*\b(cover|engage)\b[\s,]*\bgroup\b[\s,]*(?:bullseye[\s,]*)?(\d{5,6})\b/i
);

  if (!m) return false;                           // not our phrase

  const verb   = m[1].toLowerCase();              // cover | engage
  const code   = m[2];                            // 5/6-digit string
  const brgRef = (+code.slice(0,3) || 360);       // 000 â‡’ 360
  const rngRef = +code.slice(3);                  // 2- or 3-digit range

  /* â”€â”€ pick contacts inside Â±3Â° / Â±5 NM gate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const gate   = tracks.filter(t=>{
    if (t.destroyed || t.friendly || t.isTbm) return false;
    const aErr = angDiff(bearing(bullseye,t), brgRef);
    const rErr = Math.abs(distNm(bullseye,t) - rngRef);
    return aErr<=3 && rErr<=5;
  });

  if (!gate.length){
     speakFast(`${ADAFCO}, ${ICC}, clean group bullseye ${speakBE(brgRef, rngRef)}`
);
    return true;
  }

  /* â”€â”€ coverage gate â€“ same rule as parseCmd() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const inCovList = gate.filter(inCov);           // reuse your helper
  if (!inCovList.length){
speakFast(`${ADAFCO}, ${ICC},birds negate group bullseye ${speakBE(brgRef, rngRef)}`
);
    return true;
  }

  /* â”€â”€ execute the requested action â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  if (verb === 'cover'){
    doCover(inCovList);
    const n = inCovList.length;
    speakFast(`${ADAFCO}, ${ICC}, birds affirm group bullseye ${speakBE(brg, rg)}, ` +
  `${list.length} contact${list.length > 1 ? 's' : ''}`
);
  } else {                                        // engage
    inCovList.forEach(t => engageTrack(t));
    const n = inCovList.length;
    speakFast(`${ADAFCO}, ${ICC}, birds away group bullseye ${speakBE(brgRef, rngRef)}, ` +
  `${n} contact${n > 1 ? 's' : ''}`
);
    
  }
  return true;
}



/**
 * Voice-parser for â€œcover / engage / hold fire + 5-digitâ€
 * â€“ if 5-digit matches a live track ID â‡’ act on that track (only it)
 * â€“ else 5-digit â‡’ bearing/range; pick closest contact, then every
 *   hostile/cruise within Â±5 NM & Â±5Â° around that â€œanchorâ€ â†’ act on group
 * Returns true when it consumes the utterance.
 */
function coverEngageHoldFive(raw){
  const txt   = raw.toLowerCase().replace(/[,/]/g,' ').replace(/\s+/g,' ');
  const words = txt.split(' ');

  /* verb gate --------------------------------------------------- */
  let verb=null;
  if(words.includes('cover'))         verb='cover';
  else if(words.includes('engage'))   verb='engage';
  else if(words.join(' ').includes('hold fire')) verb='hold';
  if(!verb) return false;                                // not our command

  /* require exactly one 5-digit numeric string ------------------ */
  const code = extractFiveDigits(words);
  if(!code) return false;

  /* 1) match by Track-ID --------------------------------------- */
  const byId = tracks.filter(t=>t.id===code && !t.destroyed);
  if(byId.length){
    executeAction(verb, byId);
    return true;
  }

  /* 2) treat as bullseye B/R ----------------------------------- */
  const bearingBrg = +code.slice(0,3) || 0;              // 000 â†’ 360 OK
  const rangeNm    = +code.slice(3);                     // 00-99

  /* find the single nearest hostile/cruise to that B/E point */
  const iax = bullseye.x + Math.sin(d2r(bearingBrg))* (rangeNm/CFG.nmPerPixel);
  const iay = bullseye.y - Math.cos(d2r(bearingBrg))* (rangeNm/CFG.nmPerPixel);

  let anchor=null, best=1e9;
  tracks.forEach(t=>{
    if(t.destroyed||t.friendly||t.isTbm) return;
    const d = Math.hypot(t.x-iax,t.y-iay);
    if(d<best){ best=d; anchor=t; }
  });
  if(!anchor){
speakFast(
  `birds negate group bullseye ${speakBE(brgRef, rngRef)}`
);
    return true;
  }

  /* collect every hostile/cruise within Â±5Â° & Â±5 NM of anchor */
  const group = tracks.filter(t=>{
    if(t.destroyed||t.friendly||t.isTbm) return false;
    const a = angDiff(bearing(anchor,t),bearing(anchor, bullseye)); // anchor-centric
    return a<=5 && distNm(anchor,t)<=5;
  });

  if(!group.length){
speakFast(
  `birds negate group bullseye ${speakBE(brgRef, rngRef)}`
);
    return true;
  }

  executeAction(verb, group, bearingBrg, rangeNm);
  return true;
}

/* perform COVER / ENGAGE / HOLD on an array, plus voice-feedback */
function executeAction(verb,list,brg,rg){
  if(verb==='cover'){
    doCover(list);
    speakFast(
  `birds affirm group bullseye ${speakBE(brg, rg)}, ` +
  `${list.length} contact${list.length > 1 ? 's' : ''}`
);
  }
  else if(verb==='engage'){
    list.forEach(t=>engageTrack(t));        // your existing missiles-out helper
    speakFast(
  `birds away group bullseye ${speakBE(brgRef, rngRef)}, ` +
  `${n} contact${n > 1 ? 's' : ''}`
);
  }
  else{                                     // hold fire
    doHold(list);
    speakFast(`hold fire group bullseye ${brg}/${rg}`);
  }
}


  /*****************************************************************
 *  SMART BULLSEYE MATCHER  â€“  FULL REPLACEMENT
 *****************************************************************/
/*****************************************************************
 *  STRICT PARSER  â€“ drop-in for parseCmd(raw)
 *  â€¢ requires the exact form
 *        "guardian bigfoot <verb> â€¦"
 *    where <verb> is cover | engage | hold fire
 *  â€¢ ignores anything else (returns silently)
 *  â€¢ if a verb is recognised but no track is resolved,
 *    says â€œsay track numberâ€ ONCE, then waits.
 *  â€¢ remembers the last good order so you can just say
 *    the 5-digit number next (â€œone two three four fiveâ€).
 *****************************************************************/
 let lastVoiceAction  = null;      // reuse these globals
let lastVoiceTargets = null;

function parseCmd(raw) {
  /* 1 â”€ normalise (+bullseye homophones) */
  const txt = normaliseBullseye(
                raw.toLowerCase()
                   .replace(/[,/]/g, ' ')
                   .replace(/\s+/g, ' ')
                   .trim()
              );
  if (txt.includes('bullseye') || txt.includes('group')) return false;

  /* 2 â”€ must start with the callsigns */
  if (!txt.startsWith('guardian bigfoot ')) return;

  /* 3 â”€ split into tokens AFTER the callsigns */
  const words = txt.split(' ').slice(2);          // drop â€œguardian bigfootâ€
  if (!words.length) return;

  /* 4 â”€ verb MUST be the next word(s)  */
  let action = null;
  if (words[0] === 'cover') {
    action = 'cover';
    words.shift();
  } else if (words[0] === 'engage') {
    action = 'engage';
    words.shift();
  } else if (words[0] === 'hold' && words[1] === 'fire') {
    action = 'hold';
    words.shift();   // remove 'hold'
    words.shift();   // remove 'fire'
  } else {
    /* heard â€œguardian bigfoot â€¦â€ but no valid verb â†’ stay silent */
    return;
  }

  /* 5 â”€ explicit 5-digit track id (anywhere after the verb) */
  const trackNum = words.find(w => /^\d{5}$/.test(w));

  /* 6 â”€ bullseye parsing (only if no trackNum) */
  let beBearing = null, beRange = null;
  if (!trackNum) {
    const bi = words.indexOf('bullseye');
    if (bi >= 0) {
      const spoken = words.slice(bi + 1).join(' ');
      const word2num = w =>
        ({zero:0,oh:0,one:1,two:2,three:3,four:4,five:5,six:6,seven:7,
          eight:8,nine:9,ten:10,eleven:11,twelve:12,thirteen:13,fourteen:14,
          fifteen:15,sixteen:16,seventeen:17,eighteen:18,nineteen:19,
          twenty:20,thirty:30,forty:40,fifty:50,sixty:60,seventy:70,
          eighty:80,ninety:90}[w] ?? parseInt(w,10)) || 0;

      const nums = [];
      spoken.split(' ').forEach(w => {
        if (/^\d+$/.test(w))                 { nums.push(+w); return; }
        if (w === 'hundred' || w === 'thousand')             return;
        const v = word2num(w); if (v) nums.push(v);
      });
      if (nums.length >= 2) {
        beRange   = nums.pop();              // last block = range
        beBearing = +nums.join('');          // rest      = bearing
      }
    }
  }

  /* 7 â”€ resolve targets */
  const angDiff = (a,b) => Math.min(Math.abs(a-b), 360 - Math.abs(a-b));
  let targets = [];

  if (trackNum) {
    targets = tracks.filter(t => t.id === trackNum && !t.destroyed);
  } else if (beBearing !== null && beRange !== null) {
    targets = tracks.filter(t => {
      if (t.destroyed || t.friendly) return false;
      const brg = bearing(bullseye, t);
      const rng = distNm(bullseye, t);
      return angDiff(brg, beBearing) <= 5 && Math.abs(rng - beRange) <= 5;
    });
    if (targets.length) {
      const ref = targets[0];
      targets = tracks.filter(t =>
        !t.destroyed && !t.friendly && distNm(ref, t) <= 5
      );
    }
      /* â”€â”€ no match?  let the next voice-handler try instead â”€â”€ */
  if (!targets.length) return false;
  }


/* 9 â€“ coverage gate */
if (action !== 'hold' && targets.length && !targets.some(inCov)) {
  radioSay(`${ADAFCO}, ${ICC}, birds negate track ${targets[0].id}`);
  return;
}


  /* 10 â”€ execute */
  switch (action) {
   case 'cover':  doCover(targets);  return true;
    case 'engage': doEngage(targets); return true;
// â†Â right here, fire your â€œWâ€ logic:
  // either simulate the keypress:
  window.dispatchEvent(new KeyboardEvent('keydown', {
    key: 'w', code: 'KeyW', keyCode: 87, which: 87
  }));
// or if you have a helper fireKey(k):
// fireKey('w');
  break;


    case 'hold':   doHold(targets);   return true;
  }

  /* 11 â”€ remember for â€œfollow-up number onlyâ€ */
  lastVoiceAction  = action;
  lastVoiceTargets = targets;
if (!targets.length) return false;

}

/*****************************************************************
 *  ACTION HELPERS  (use your existing logic wherever possible)
 *****************************************************************/
 function radioSay(line) {
  const msg = line.replace(/\s+/g,' ').trim();

  // â–¸ new: never speak the same thing twice
  if (msg === lastRadioLine) return;
  lastRadioLine = msg;

  statusEl.textContent = msg;
  speakFast(msg);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ PUSH-TO-TALK (hold CTRL) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const _ttsQueue = [];          // buffered utterances
let   _micHot   = false;       // true while CTRL is held

window.addEventListener('keydown', e=>{
  if (e.key === 'Control') {
    _micHot = true;
    speechSynthesis.cancel();  // stop talking over you
  }
});

window.addEventListener('keyup', e=>{
  if (e.key === 'Control') {
    _micHot = false;
    while (_ttsQueue.length) _ttsQueue.shift()();  // flush queue
  }
});

function speakFast(text){
  const job = () => {
    const u  = new SpeechSynthesisUtterance(text);
    u.rate   = 1.9;            // â‰ˆ2Ã— normal
    u.lang   = 'en-US';
    speechSynthesis.speak(u);
  };

  if (_micHot) {               // user is transmitting
    _ttsQueue.push(job);       // â†’ speak later
  } else {
    job();                     // â†’ speak now
  }
}

/* ---------- COVER ---------- */
function doCover(arr){
  arr.forEach(t=>{
    t.tag='COVER'; t.tagTime=Date.now();
  });
  const be = formatBE(arr[0]);
  radioSay(`bigfoot guardian birds affirm track ${arr[0].id} bullseye ${be.replace('/',' ')}`);
}

/* ---------- ENGAGE ---------- */
function doEngage(arr){
  arr.forEach(t=>{
    launch(t);              // missiles out
  });
  const be = formatBE(arr[0]);
 radioSay(`bigfoot guardian birds away track ${arr[0].id} bullseye ${be.replace('/',' ')}`);
}

/* ---------- HOLD FIRE ---------- */
function doHold(arr){
  arr.forEach(t=>{
    t.tag='ENGAGE';              // return to ENGAGE
    /* cancel missiles exactly like old H-key logic */
    missiles = missiles.filter(m=>!arr.includes(m.target));
    if(t.mslTimer){ clearTimeout(t.mslTimer); t.mslTimer=null; }
  });
  const be = formatBE(arr[0]);
  radioSay(`bigfoot guardian hold fire track ${arr[0].id} bullseye ${be.replace('/',' ')}`);
}


// â‘  Extract all of your â€œWâ€ logic into one helper:
function engageTrack(t) {
  // 1) immediate SL/AWAY callâ€‘out
  const quad = getQuadrant(t);
  statusEl.textContent    = `SL, ADAFCO, BIRDS AWAY ${quad}`;

  // NEW:
// 1) decide which launcher to use:
const NASAMS       = statics.find(s => s.id === 'NASAMS');
const inNASAMSRing = NASAMS && distNm(NASAMS, t) <= 20;
const fu          = inNASAMSRing ? NASAMS : closestFu(t);

// 2) check reload & ammo for this FU
const distFu = distNm(fu, t);
if (fu.id === 'NASAMS') {
  // NASAMS uses checkNASAMSStatus (unchanged)
if (checkNASAMSStatus(inNASAMSRing)) {
      // NASAMS canâ€™t fire right now â†’ birds negate
      radioSay(`${ADAFCO}, ${ICC}, birds negate track ${t.id}`);
      return;
    }
  STATS.missilesUsed.aim120 += 2;   //  â† add this
} else {
  // Patriot uses our new mixedâ€‘mag logic
  if (!processPatriotEngagement(fu, distFu)) return;
}


const speedPxPerSec = ( (t.isTbm ? 5000 : 3600) / 3600 ) / CFG.nmPerPixel;
const ttlMs         = 70 * 1000;

// 2) if any friendly sits within 5â€¯NM, only reâ€‘target *nonâ€‘cruise* tracks
let assignedTarget = t;
if (!t.isCruise) {
  const nearbyFriendly = tracks.find(o =>
    o.friendly && distNm(o, t) <= 5
  );
  if (nearbyFriendly) assignedTarget = nearbyFriendly;
}


// â”€â”€â”€ 3) launch two missiles, 2â€¯s apart
// â†’ first missile immediately
missiles.push({
  x:           fu.x,
  y:           fu.y,
  target:      assignedTarget,
  fu:          fu,
  speedPxPerSec,
  expire:      Date.now() + ttlMs
});


// â†’ second missile after 2â€¯s
setTimeout(() => {
  missiles.push({
    x:           fu.x,
    y:           fu.y,
    target:      assignedTarget,
    fu:          fu,
    speedPxPerSec,
    expire:      Date.now() + ttlMs
  });
}, 2000);


// 4) schedule the impact check on the original hostile
scheduleImpactCheck(t);


   // â”€â”€â”€ now do the levelâ€‘scaled jinking for any nonâ€‘friendly â”€â”€â”€â”€â”€â”€â”€â”€â”€
   const jinkProb = Math.min(1, 0.5 + 0.1*(level-1));
   if (!t.friendly && !t.isTbm && !t.isCruise && Math.random() < jinkProb) {
     const waitMs = (10 + Math.random()*20)*1000;
     setTimeout(() => {
       const turn = (90 + Math.random()*90) * (Math.random()<0.5?1:-1);
       t.heading = (t.heading + turn + 360)%360;
       t.isEvading = true;
       setTimeout(() => {
         t.isEvading = false;
         t.heading   = bearing(t, bullseye);
       }, 60000);
     }, waitMs);
   }

   // NOW fall through into the rest of your friendly vs. hostile logicâ€¦

  // check if this wedge is still red
if (selectedStatic && selectedStatic.type === 'rad') {
  const s = selectedStatic;
  if (Date.now() < s.disabledUntil) {
    feedbackEl.textContent = 'Radar Redâ€”no Engagements possible from this FU';
    return;
  }
}
  
    // â”€â”€ now falls into Branch A1/B/C exactly as before â”€â”€â”€â”€â”€â”€â”€
  // 1) Compute geometry gate
  const now = Date.now();

// ICC circle test stays the same
const icc      = statics.find(s => s.type === 'icc');
const inCircle = icc && distNm(icc, t) <= 15;

// ONLY consider wedges that are both:
//   â€¢ not midâ€‘animation  (animFrom == null)
//   â€¢ not still red/disabled (now >= disabledUntil)
const inWedge = statics
  .filter(s =>
    s.type       === 'rad'    &&
    s.wedgeDir   != null      &&
    s.animFrom   == null      &&
    now          >= s.disabledUntil
  )
  .some(s => insideWedge(s, t));

const possible = inCircle || inWedge;



const isInsideCircle = NASAMS && distNm(NASAMS, t) <= 15;

  // Only block if the selected FU is NASAMS and itâ€™s reloading
  if (fu.id === 'NASAMS' && checkNASAMSStatus(isInsideCircle)) {
    return;
  }

// â”€â”€â”€ All AWAY shots now go to intercept schedule â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 
  statusEl.textContent =
    `SL, ADAFCO, BIRDS AWAY Track ${t.id}, B/E ${('000' + bearing(bullseye, t)).slice(-3)}/${distNm(bullseye, t)}`;

    // only penalize birdsâ€‘away if SL never requested ENGAGE
  if (t.tag !== 'ENGAGE' && !t.everEngaged) {
      // only levy the ROE penalty when REDWOOD isnâ€™t hot in this quadrant
  if ( roePenaltyAllowed(t) ) {
    changeScore(-5, 'ROE Violation: -5');
    STATS.roeViolations++;
    t.everEngaged = true;
  }}

  // schedule the impact check (inside or outside will be decided there)
  scheduleImpactCheck(t);

 
}



// â‘¢ And have launch() just call that same helper:
function launch(t) {
  engageTrack(selectedTrack);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Guardian â†” Bigfoot  v3.3  (multi-track, multi-verb) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const ICC = 'guardian', ADAFCO = 'bigfoot';
const SR  = window.SpeechRecognition || window.webkitSpeechRecognition;
const synth = window.speechSynthesis;

/* ===== speech helpers ===== */
function speak(t){ if(!synth) return;
  const u = new SpeechSynthesisUtterance(t);
  u.rate  = 1.9;
  u.lang  = 'en-US';
  synth.speak(u);
}



/* ===== coverage, cluster, BE helpers (unchanged) ===== */
function inCov(o){
  const n = Date.now(), nas = statics.find(s=>s.id==='NASAMS');
  if(nas && distNm(nas,o) <= 20) return true;
  return statics.some(r => r.type==='rad' && n>=r.disabledUntil
                        && insideWedge(r,o) && distNm(r,o) <= 80);
}
// put this once, near your helpers
function speakBE(bearingDeg, rangeNm) {
  const digits = ['zero','one','two','three','four','five',
                  'six','seven','eight','nine'];

  // bearing: force 3 digits (000â†’360) and speak each digit
  const bStr = ('000' + (bearingDeg % 360 || 360)).slice(-3);   // 000â†’360
  const bW   = bStr.split('').map(d => digits[+d]).join(' ');   // "zero two five"

  // range: ordinary cardinal words (Intl handles 1-999 neatly)
  const rW = new Intl.NumberFormat('en')
                .format(rangeNm)
                .replace(/,/g,'')
                .split(' ')
                .join('-');                                     // "twenty-five"

  return `${bW} ${rW}`;
}

/* â‡£  replace the old version with this one â‡£ */
function wordsBE(t) {
  return speakBE(bearing(bullseye, t), distNm(bullseye, t));
}

/**
 * Returns true if the launcher that would engage track `t`
 * currently has ammo *and* isnâ€™t reloading.
 */
function hasMissiles(t) {
  const now = Date.now();

  // 1) Is it a NASAMS shot (inside 20 NM)?
  const nasams       = statics.find(s => s.id === 'NASAMS');
  const inNasamsRing = nasams && distNm(nasams, t) <= 20;

  // 2) Pick the right launcher
  const launcher = inNasamsRing
    ? nasams
    : closestFu(t);         // your existing helper, finds nearest FU

  if (!launcher) return false;

  // 3) NASAMS needs 2 AIM-120s per intercept, and obeys its reload timer
  if (launcher.id === 'NASAMS') {
    if (now < NASAMSDisabledUntil)          return false;  // still reloading
    return NASAMSMissiles >= 2;                      // need â‰¥2 missiles
  }

  // 4) Patriots consume â€œengagementsâ€ (2 missiles) and obey their reload timer
  if (now < launcher.disabledUntilFu)     return false;  // FU still reloading
  return launcher.engagementsRemaining > 0;              // need â‰¥1 engagement left
}

/* ---------- ACTIONS ---------- */
// â€”â€”â€”â€”â€”â€”â€”â€” COVER â€”â€”â€”â€”â€”â€”â€”â€”
function doCover(list){
  // in coverage & have ammo
  const affirm     = list.filter(t => inCov(t) && hasMissiles(t));
  // in coverage but no ammo
  const noAmmo     = list.filter(t => inCov(t) && !hasMissiles(t));
  // out of coverage (we donâ€™t care about ammo here)
  const negate     = list.filter(t => !inCov(t));

  affirm.forEach(t=>{
    t.tag     = 'COVER';
    t.tagTime = Date.now();
  });

  if (affirm.length) {
    speak(`${ADAFCO}, ${ICC}, birds affirm track ${affirm.map(t=>t.id).join(', ')}.`);
  }
  if (noAmmo.length) {
    speak(`${ADAFCO}, ${ICC}, birds negate track ${noAmmo.map(t=>t.id).join(', ')} (no missiles).`);
  }
  if (negate.length) {
    speak(`${ADAFCO}, ${ICC}, birds negate track ${negate.map(t=>t.id).join(', ')}.`);
  }
}

// â€”â€”â€”â€”â€”â€”â€”â€” ENGAGE â€”â€”â€”â€”â€”â€”â€”â€”
function doEngage(list){
  // in coverage & have ammo â†’ we can actually engage (birds away)
  const ok         = list.filter(t => inCov(t) && hasMissiles(t));
  // in coverage but no ammo â†’ canâ€™t engage
  const noAmmo     = list.filter(t => inCov(t) && !hasMissiles(t));
  // out of coverage
  const bad        = list.filter(t => !inCov(t));

  ok.forEach(t=>{
    engageTrack(t);  // your existing W-logic
  });

  if (ok.length) {
    speak(`${ADAFCO}, ${ICC}, birds away track ${ok.map(t=>t.id).join(', ')}.`);
  }
  if (noAmmo.length) {
    speak(`${ADAFCO}, ${ICC}, birds negate track ${noAmmo.map(t=>t.id).join(', ')} (no missiles).`);
  }
  if (bad.length) {
    speak(`${ADAFCO}, ${ICC}, birds negate track ${bad.map(t=>t.id).join(', ')}.`);
  }
}
function doHold(list){
  list.forEach(t=>abort(t));   // reuse existing abort()
  speak(`${ADAFCO}, ${ICC}, hold fire track ${list.map(t=>t.id).join(', ')}.`);
}

/* ===== MAIN PARSER ===== */
function parseCmd(raw){
  /* 1 â”€ normalise (and short-circuit if we saw "bullseye") */
  const txt0 = raw.toLowerCase();
  if (txt0.includes('bullseye')) return false;   // let other handlers try
  const txt = txt0
                 .replace(/[,/]/g,' ')
                 .replace(/\s+/g,' ')
                 .trim();
  if(!txt.startsWith('guardian bigfoot ')) return;
  const tok = txt.split(' ').slice(2);          // drop callsigns
  if(!tok.length) return;

  /* 2 â”€ scan tokens and build {act, ids[]} chunks */
  const chunks = [];                  // [{act:'cover', ids:[â€¦]}, â€¦]
  const isVerb = (w,i)=> w==='cover' || w==='engage' || (w==='hold'&&tok[i+1]==='fire');
  let i=0;
  while(i<tok.length){
    if(!isVerb(tok[i],i)){ i++; continue; }

    let act=null;
    if(tok[i]==='cover'){ act='cover'; i++; }
    else if(tok[i]==='engage'){ act='engage'; i++; }
    else{ act='hold'; i+=2; }         // skip "hold fire"

    if(tok[i]==='track'||tok[i]==='tracks') i++;  // optional noise word

    const ids=[];
    while(i<tok.length && !isVerb(tok[i],i)){
      const w = tok[i].replace(/[^0-9]/g,'');      // strip commas/ands
      if(/^\d{3,5}$/.test(w)) ids.push(w);
      i++;
    }
    if(ids.length) chunks.push({act,ids});
  }
  if(!chunks.length) return;          // nothing actionable

  /* 3 â”€ execute each chunk */
  chunks.forEach(({act,ids})=>{
    const targets = tracks.filter(t => ids.includes(t.id) && !t.destroyed);
    if(!targets.length){
      speak(`${ADAFCO}, ${ICC}, say track number.`);
      return;
    }
    if(act==='cover')  doCover(targets);
    else if(act==='engage') doEngage(targets);
    else                doHold (targets);

    // remember last *single-verb* list for quick follow-up
    lastVoiceAction  = act;
    lastVoiceTargets = targets;
  });
}


/* ===== LAST-NUMBER FOLLOW-UP ===== */
function repeatLastIfNumberOnly(txt){
  const m = txt.match(/\b(\d{5})\b/);
  if(!m || !lastVoiceAction || !lastVoiceTargets) return false;
  const t = tracks.find(o=>o.id===m[1]&&!o.destroyed);
  if(!t) return false;
  if(lastVoiceAction==='cover')   doCover([t]);
  else if(lastVoiceAction==='engage') doEngage([t]);
  else                             doHold ([t]);
  return true;
}

/**
 * Simplified, â€œignore the restâ€ voice handler:
 *  â€¢ Finds the first 5â€“6 digit block (slashes allowed)
 *  â€¢ Throws away everything after it
 *  â€¢ Detects one verb: hold|cover|engage
 *  â€¢ If digits exactly match a live track ID â†’ act on that track
 *  â€¢ Otherwise â†’ treat as bullseye (group) and act on all hits in Â±3Â°/Â±5 NM
 */
function handleSimpleCommandVoice(raw) {
  const lower = raw.toLowerCase();

  /* 1â€Šâ€”â€Šdetect the verb first ----------------------------------- */
  let action = null;
  if (/\bhold(?:s|ing)?\b/.test(lower))        action = 'hold';
  else if (/\bcover(?:s|ed|ing)?\b/.test(lower)) action = 'cover';
  else if (/\bengag(?:e|ed|ing)?\b/.test(lower)) action = 'engage';
  if (!action) return false;          // not our phrase â†’ let other handlers try

  /* 2â€Šâ€”â€Šgrab every digit in order --------------------------------*/
  const allDigits = (raw.match(/\d/g) || []).join('');

  /* 2aâ€Šâ€”â€Šverb but <5 digits â†’ ask again and bail -----------------*/
  if (allDigits.length < 5) {
    speakFast(`${ADAFCO}, ${ICC}, say command and track number.`);
    return true;                      // handled; no further processing
  }

  /* 3â€Šâ€”â€Šnormal simple-command logic (unchanged) ------------------*/
  const code5 = allDigits.slice(0, 5);
  const code6 = allDigits.length >= 6 ? allDigits.slice(0, 6) : null;

  // 3a â€” exact track-ID
  const trk = tracks.find(t => t.id === code5 && !t.destroyed);
  if (trk) {
    if (action === 'cover')       doCover([trk]);
    else if (action === 'engage') doEngage([trk]);
    else                          doHold([trk]);
    return true;
  }

  // 3b â€” 5-digit Bullseye gate Â±3Â° / Â±5 NM
  const br5 = (+code5.slice(0, 3) || 360);
  const rn5 = +code5.slice(3);
  let hits = tracks.filter(t => {
    if (t.destroyed || t.friendly || t.isTbm) return false;
    return angDiff(bearing(bullseye, t), br5) <= 3 &&
           Math.abs(distNm(bullseye, t) - rn5) <= 5;
  });
  if (hits.length) {
    if (action === 'cover')       doCover(hits);
    else if (action === 'engage') doEngage(hits);
    else                          doHold(hits);
    return true;
  }

  // 3c â€” 6-digit Bullseye (if you spoke â‰¥6 digits)
  if (code6) {
    const br6 = (+code6.slice(0, 3) || 360);
    const rn6 = +code6.slice(3);
    hits = tracks.filter(t => {
      if (t.destroyed || t.friendly || t.isTbm) return false;
      return angDiff(bearing(bullseye, t), br6) <= 3 &&
             Math.abs(distNm(bullseye, t) - rn6) <= 5;
    });
    if (hits.length) {
      if (action === 'cover')       doCover(hits);
      else if (action === 'engage') doEngage(hits);
      else                          doHold(hits);
      return true;
    }
  }

  /* 4â€Šâ€”â€Šstill nothing matched â†’ generic prompt -------------------*/
  speakFast(`${ADAFCO}, ${ICC}, say command and track number.`);
  return true;
}


/* ------------------------------------------------------------------
   getWeaponsState(fu)  â†’  'Green' | 'Yellow' | 'Red'
   ------------------------------------------------------------------ */
function getWeaponsState(fu){
  /* Patriot: use fu.ammo totals; NASAMS: NASAMSMissiles               */
  const remaining = fu.id === 'NASAMS'
      ? NASAMSMissiles
      : fu.ammo.pac2 + fu.ammo.pac3 + fu.ammo.mse;

  const max = fu.id === 'NASAMS' ? 18 : 12+16+24;   // 18 AIM-120s  or 52 Patriot
  const pct = remaining / max;

  if (pct > 0.50) return 'Green';
  if (pct > 0.25) return 'Yellow';
  return 'Red';
}

/* ------------------------------------------------------------------*/
/*  What-State voice query                                           */
/* ------------------------------------------------------------------*/
function handleWhatStateVoice(txt){
  // allow any punctuation and optional â€œguardian bigfoot â€¦â€
  if (!/what\s+state\b/i.test(txt)) return false;      // phrase absent
  if (/\d{5}/.test(txt))          return false;        // ignore if numbers

  const fus = statics.filter(s => s.type === 'fu');    // Patriots + NASAMS
  const lines = fus.map(fu => {
    const qMap = { NE:'North East', NW:'North West',
                   SE:'South East', SW:'South West' };
    const name = fu.id === 'NASAMS'
      ? 'NAY-SAMs'
      : qMap[getFuLabel(fu).split(' ')[0]] + ' Firing Unit';
    return `${name} Weapons ${getWeaponsState(fu)}`;
  });

  speakFast(`${ADAFCO}, ${ICC}, ${lines.join(', ')}`);
  return true;                                         // handled
}



// 1) List your handlers in the exact order they should run:
const voiceHandlers = [
  { name: 'Redwood-Hot',         match: handleRedwoodHotVoice },
  { name: 'Fireball',            match: fireballVoice },
  { name:'What-State',    match:handleWhatStateVoice },  // â† new
  { name: 'Group Bullseye',      match: groupBullseyeVoice },
  { name: 'Cover/Engage 5-Digit',match: coverEngageHoldFive },
  { name: 'Repeat Last Number',  match: repeatLastIfNumberOnly },
  { name: 'PTL Reorient',       match: handleReorientVoice },
  { name: 'Simple Command',          match: handleSimpleCommandVoice }, 
  


  // â€¦any true â€œfinal fallbackâ€ you still wantâ€¦
];

function onTranscript(raw) {
  const txt = raw.toLowerCase().trim();
  for (const { name, match } of voiceHandlers) {
    try {
      if ( match(txt) ) {
        console.log(`ğŸ™ï¸  Voice handled by: ${name}`);  // <-- logs which handler ran
        return;
      }
    } catch (err) {
      console.error(`Error in handler ${name}:`, err);
    }
  }
  // nothing matched
  console.log(`â“  No handler matched for â€œ${txt}â€`);
  radioSay(`${ADAFCO}, ${ICC}, say again last.`);
}

/* ===== speech-recognition wiring ===== */
let recog=null, mic=false;
function micInit(){
  if(!SR){ alert('Speech-to-text not supported'); return; }
  if(recog){ recog.start(); mic=true; return; }

function normaliseBullseye(txt){
  return txt
    /* bullseye homophones (optional now) */
    .replace(/\bside\b/gi,  'bullseye')
    .replace(/\bsides\b/gi, 'bullseye')
       .replace(/\bboth\b/gi, 'bullseye')
    .replace(/\bbull side\b/gi,  'bullseye')
       .replace(/\bbull\b/gi, 'bullseye')
          .replace(/\beye\b/gi, 'bullseye')
             .replace(/\bbulls\b/gi, 'bullseye')
    /* NEW â€” group homophones */
    .replace(/\bgrew(p|ve)?\b/gi, 'group')   // grew, grew-up, groove
    .replace(/\bgroup\b/gi,      'group');
}


  recog=new SR(); recog.lang='en-US'; recog.continuous=true; recog.interimResults=false;
recog.onresult = e => {
  const raw = e.results[e.resultIndex][0].transcript;
  onTranscript(raw);
};
  recog.onerror=e=>console.error(e);
  recog.start(); mic=true;
}

/* ===== mic button & Ctrl push-to-talk ===== */
(()=>{ if(document.getElementById('micBtnRadio')) return;
  const btn = document.createElement('button');
  btn.id='micBtnRadio'; btn.textContent='ğŸ™ï¸ Mic OFF';
  btn.onclick = ()=>{ if(!mic){micInit();btn.textContent='ğŸ™ï¸ Mic ON';}
                      else{recog.stop();mic=false;btn.textContent='ğŸ™ï¸ Mic OFF';}};
  document.getElementById('controls').appendChild(btn);
})();
const micBtn = document.getElementById('micBtnRadio');
window.addEventListener('keydown',e=>{
  if(!e.repeat && e.key==='Control'){
    if(speechSynthesis.speaking) speechSynthesis.cancel();
    micInit(); mic=true; micBtn.textContent='ğŸ™ï¸ Mic ON';
  }
});
window.addEventListener('keyup',e=>{
  if(e.key==='Control'&&mic){
    if(recog) recog.stop();
    mic=false; micBtn.textContent='ğŸ™ï¸ Mic OFF';
  }
});

/* Turn â€œSLâ€ into â€œS Lâ€ and â€œADAFCOâ€ into â€œadaf-coâ€ for speech */
function ttsFix(line){
  // 1) callsigns
  line = line
    .replace(/\bSL\b/gi,   'S L')
    .replace(/ADAFCO/gi,   'ah-dahff-kho');

  // 2) quadrant codes â†’ full words + â€œQuadrantâ€
  const quadMap = {
    'NE': 'North East',
    'NW': 'North West',
    'SE': 'South East',
    'SW': 'South West'
  };
  line = line.replace(/\b(N[EW]|S[EW])\b/gi,
    m => quadMap[m.toUpperCase()]
  );

  return line;
}


/**
 * parseBE(text):
 *   takes the words spoken after â€œbullseyeâ€
 *   returns an object { bearing, range } if it finds at least two numbers,
 *   or an empty object otherwise.
 */
 function parseBE(text) {
  const word2num = {
    zero:0, oh:0, one:1, two:2, three:3, four:4, five:5,
    six:6, seven:7, eight:8, nine:9, ten:10, eleven:11,
    twelve:12, thirteen:13, fourteen:14, fifteen:15, sixteen:16,
    seventeen:17, eighteen:18, nineteen:19, twenty:20, thirty:30,
    forty:40, fifty:50, sixty:60, seventy:70, eighty:80, ninety:90
  };

  // split into words, pull out any numeric or wordâ€‘number tokens
  const parts = text.trim().toLowerCase().split(/\s+/);
  const nums = [];
  parts.forEach(w => {
    if (/^\d+$/.test(w)) {
      nums.push(parseInt(w, 10));
    } else if (word2num[w] != null) {
      nums.push(word2num[w]);
    }
    // ignore "hundred", "thousand", etc.
  });

  if (nums.length < 2) return {};

  // last number is range, the rest form the bearing digits
  const range   = nums.pop();
  const bearing = parseInt(nums.map(n => String(n)).join(''), 10);

  return { bearing, range };
}

/* parse voice command */
function parseCmd(raw){
  let act=null;
  if(/cover/.test(raw)) act='cover';
  else if(/engage/.test(raw)) act='engage';
  else if(/hold\s+fire/.test(raw)) act='hold';

  /* explicit track number */
  const nMatch=raw.match(/\b(\d{3,5})\b/); const trackId=nMatch?nMatch[1]:null;

  /* bullseye part */
  const bx=raw.match(/bullseye([^]*)/); let brg=null,rng=null,pt=null;
  if(bx){({brg,rng}=parseBE(bx[1])); if(brg) pt=beToWorld(brg,rng);}

  /* find targets */
  let targets=[];
  if(trackId){
    const t=tracks.find(o=>o.id===trackId&&!o.destroyed); if(t) targets=[t];
  }
  if(!targets.length && pt) targets=cluster(pt);


/* coverage check for cover / engage */
if (act !== 'hold' && !targets.some(inCov)) {
  const id = targets[0].id;
  speak(`${ADAFCO}, ${ICC}, BIRDS NEGATE track ${id}`);
  return;
}


  /* confirmation when off by >5 NM and derived from bullseye */
  if(!trackId && pt){
    const d=distNm(pt,targets[0]);
    if(d>5){
      pending={act,tracks:targets};
      speak(`${ADAFCO}, ${ICC}, confirm ${act} request for track ${targets[0].id}, bullseye ${wordsBE(targets[0])}?`);
      return;
    }
  }

  doAction(act,targets);
}
/* execute */
function doAction(act,arr){
  arr.forEach(t=>{
    const txt=wordsBE(t);
    if(act==='cover'){
      speak(`Bigfoot, Guardian, birds affirm track ${t.id}, bullseye ${txt}.`);
      /* tag stays COVER until you hit A manually â€“ no auto change */
    }
    else if(act==='engage'){
      speak(`Bigfoot, Guardian, birds away track ${t.id}, bullseye ${txt}.`);
      launch(t);               // missiles out
      /* NO automatic tag change â€” user will press W */
    }
    else{ // hold fire
      speak(`Bigfoot, Guardian, hold fire track ${t.id}, bullseye ${txt}.`);
      abortTrack(t);
    }
  });
}

/* ----- W hot-key is tag-only now ----- */
window.addEventListener('keydown',e=>{
  if(e.key.toLowerCase()==='w'&&selectedTrack){
    e.preventDefault();
    e.stopImmediatePropagation();   // â† blocks the original launcher
    selectedTrack.tag     = 'AWAY';
    selectedTrack.tagTime = Date.now();
    // mark that user communicated Birds Away
    selectedTrack._communicatedAway = true;
  }
});






/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   utility: find best track
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
function pickTrack(trackId,bearing,range){
  /* 1) by explicit track number */
  if(trackId){
    const t = tracks.find(o=>o.id===trackId && !o.destroyed);
    if(t) return t;
  }
  /* 2) fallback: any track within 5 NM of the spoken bullseye */
  if(bearing!=null && range!=null){
    return tracks.find(o=>{
      if(o.destroyed) return false;
      return Math.abs(bearingDiff(bearing,bearingBetween(bullseye,o)))<=6 &&
             Math.abs(distNm(bullseye,o)-range)<=5;
    });
  }
  return null;
}
function bearingBetween(a,b){ return bearing(a,b);}       // alias
function bearingDiff(a,b){ let d=Math.abs(a-b)%360; return d>180?360-d:d; }

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   geometry check  (Patriot wedge 60 NM Â±60Â°  OR NASAMS  â‰¤15 NM)
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
function trackInGeometry(t){
  const now = Date.now();
  const nas = statics.find(s=>s.id==='NASAMS');
  if(nas && distNm(nas,t)<=15) return true;
  return statics.some(rad=>
    rad.type==='rad' &&
    now >= rad.disabledUntil &&
    insideWedge(rad,t) &&
    distNm(rad,t)<=60
  );
}

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   1-liner helper: dispatch virtual keypress so your existing hot-key
   handlers run untouched.
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
function fireKey(k){
  window.dispatchEvent(new KeyboardEvent('keydown',{key:k}));
}

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   extract the missile-launching guts that were inside the old â€˜Wâ€™ key
   and make them callable from radio + from â€˜Wâ€™ (cosmetic).
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
function launchOnTrack(t){
  /*  â€” put the EXACT contents of your old â€œWâ€ handlerâ€™s
       â€˜launch two missilesâ€™ block here â€”
     (everything from closest-FU pick â†’ scheduleImpactCheck)
     You probably already have it factored as engageTbmWithPatriot()
     etc.  Just call that same helper.
  */
  if(t.isTbm) engageTbmWithPatriot(t);          // example
  else        fireKey('w');  // reuse existing code for conventional
};



// â†“â†“â†“  NEW â€“ must be declared before fitMobileView() ever runs
const isMobile = /Mobi|Android/i.test(navigator.userAgent);

// Distance from the very top where cards should appear
const cardTop = () =>
  isMobile ? document.querySelector('header').offsetHeight + 10 : 10;

// â”€â”€â”€ load background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const bgImg = new Image();
bgImg.src = 'images/island3.png';   // default style

const mapBtn = document.getElementById('mapBtn');
let altMap = false;  // false â†’ island3, true â†’ island4

mapBtn.addEventListener('click', () => {
  altMap = !altMap;
  bgImg.src = altMap 
    ? 'images/island4.png' 
    : 'images/island3.png';
  // (optional) update button text to show which style:
  mapBtn.textContent = altMap 
    ? 'Map: SAT' 
    : 'Map';
});

/**
 * Tag the given track and any other hostiles within 5â€¯NM as ENGAGE.
 * @param {object} mainTrack â€“ the track the SL just engaged
 * @returns {Array<object>}  â€“ the array of all tracks just engaged
 */
function engageCluster(mainTrack) {
  const now     = Date.now();
  // find all hostiles (not friendly, not destroyed) within 5â€¯NM of mainTrack
  const cluster = tracks.filter(t =>
    !t.friendly &&
    !t.destroyed &&
    t !== mainTrack &&
    distNm(mainTrack, t) <= 5
  );
  // always include the main track itself
  const all = [ mainTrack, ...cluster ];
  all.forEach(t => {
    t.tag      = 'ENGAGE';
    t.tagTime  = now;
    t.everEngaged = true;      // if you want to prevent ROE penalties later
  });
  return all;
}

/* Helper: centre view so a 200Â NM radius fits the mobile screen */
function fitMobileView() {
  if (!isMobile) return;                       // uses your existing isMobile
  const rpx      = 200 / CFG.nmPerPixel;       // 200Â NM in worldâ€‘px
  const fitScale = Math.min(worldWidth, worldHeight) / (2 * rpx);
  scale = fitScale;
  offX  = bullseye.x - (worldWidth  / 2) / scale;
  offY  = bullseye.y - (worldHeight / 2) / scale;
}

function resize () {
  worldWidth  = canvas.width  = window.innerWidth;
  const hdr   = document.querySelector('header').offsetHeight;
  worldHeight = canvas.height = window.innerHeight - hdr;

  // Build statics only once
  if (!resize.didInit) {
    buildStatics();
    resize.didInit = true;
  }

  // ğŸ‘‰ always recenter / rescale for the current viewport
  fitMobileView();
}


if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', resize);
}
resize();

// â€” trackDrag state & selection array â€”
let multiDrag   = null;
let multiSelect = [];


function updateMultiSelect() {
  const { x0, y0, x1, y1 } = multiDrag;
  const left   = Math.min(x0, x1),
        right  = Math.max(x0, x1),
        top    = Math.min(y0, y1),
        bottom = Math.max(y0, y1);

    multiSelect = tracks.filter(t => {
     if (!isTrackVisible(t)) return false; // new unified one
    const sx = (t.x - offX) * scale;
    sy = (t.y - offY) * scale - 6 * scale;   // â† raise hit-point â†‘
    return sx >= left && sx <= right && sy >= top && sy <= bottom;
  });
}

// start box on shift + left-down
canvas.addEventListener('pointerdown', e => {
  if (!shiftDown || e.button !== 0) return;
  const r = canvas.getBoundingClientRect();
  multiDrag = {
    x0: e.clientX - r.left,
    y0: e.clientY - r.top,
    x1: e.clientX - r.left,
    y1: e.clientY - r.top
  };
  e.preventDefault();
});

// update box & selection as you move
canvas.addEventListener('pointermove', e => {
  if (!multiDrag) return;
  const r = canvas.getBoundingClientRect();
  multiDrag.x1 = e.clientX - r.left;
  multiDrag.y1 = e.clientY - r.top;
  updateMultiSelect();
  e.preventDefault();
});

// finish on release: render cards
canvas.addEventListener('pointerup', e => {
  if (!multiDrag) return;
  renderMultiCards();
  multiDrag = null;
  e.preventDefault();
});

// plainâ€click (no shift) clears the group
canvas.addEventListener('click', e => {
  if (!shiftDown && !multiDrag) {
    multiSelect = [];
    clearMultiCards();
  }
});

function buildStatics(){
  const cx = worldWidth/2,
        cy = worldHeight/2,
        p10 = 10 / CFG.nmPerPixel,
        ro  = 2  / CFG.nmPerPixel;


        statics = [
  // â”€â”€â”€ ICC at center â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  { type: 'icc',   id: '00731',            x: cx,                  y: cy },

  // â”€â”€â”€ Patriot MPQâ€‘53 radars + launchers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // launcher 1 (NE)
  { type: 'rad',   id: '00170', system: 'MPQâ€‘53',     label:         'FRIEND', x: cx + p10 - 30, y: cy - p10 + 25 },
  { type: 'fu',    id: 'PATRIOT',         x: cx + p10 + ro - 30, y: cy - p10 - ro + 30 },

  // launcher 2 (SW)
  { type: 'rad',   id: '00171', system: 'MPQâ€‘53',     label:         'FRIEND', x: cx - p10 + 20, y: cy + p10 - 15 },
  { type: 'fu',    id: 'PATRIOT',         x: cx - p10 - ro + 20, y: cy + p10 + ro - 15 },

  // launcher 3 (SE)
  { type: 'rad',   id: '00172', system: 'MPQâ€‘53',     label:         'FRIEND',  x: cx + p10 - 23, y: cy + p10 - 15 },
  { type: 'fu',    id: 'PATRIOT',         x: cx + p10 + ro - 30, y: cy + p10 + ro },

  // launcher 4 (NW)
  { type: 'rad',   id: '00173', system: 'MPQâ€‘53',     label:         'FRIEND', x: cx - p10 + 20, y: cy - p10 + 20 },
  { type: 'fu',    id: 'PATRIOT',         x: cx - p10 - ro + 25, y: cy - p10 - ro + 20 },

  // â”€â”€â”€ TPSâ€‘75 Radar next to C2/HHQ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  { 
    type:          'c2Rad', 
    id:            '00069',       // JTN label
    system:        'TPSâ€‘75',          // distinct system
    label:         'FRIEND',          // ID field for card
    x:             cx,                // tweak as needed
    y:             cy + 3 / CFG.nmPerPixel 
  },
];


  /* â”€â”€ SENTINEL radar truck (replaces C2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  statics.push({
    type:   'sentinel',
    id:     '00175',      // â† JTN here
    system: 'AN/MPQ-64',
    label:  'FRIEND',
    x:      cx - 3 / CFG.nmPerPixel,
    y:      cy + 4 / CFG.nmPerPixel,
    disabledUntil: 0
  });


  // â”€â”€ C@ (friendly) icon â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  statics.push({
    type:'crc',
    id:   '00225',            // label it â€œBIGFOOTâ€
    label:         'FRIEND',          // ID field for card
    x:    cx + 3 / CFG.nmPerPixel,  
    y:    cy + 1 / CFG.nmPerPixel, 
  });

    // â”€â”€ NASAMS (friendly) icon, 15â€¯NM east of the ICC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  statics.push({
    type:'fu',
    id:   'NASAMS',            // label it â€œNASAMSâ€
    x:    cx - 3 / CFG.nmPerPixel,  // 1â€¯NM east of the bullseye (ICC)
    y:    cy + 3 / CFG.nmPerPixel, 
  });


  bullseye = { x:cx, y:cy };

  // â”€â”€â”€ Initialize each Patriot FUâ€™s ammo pool â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
statics
  .filter(s => s.type === 'fu')
  .forEach(fu => {
    fu.ammo = {           // total missiles per type
      pac2: 12,
      pac3: 16,
      mse:  24
    };
    fu.engagementsRemaining = 26;  // 2 missiles per engagement â†’ 56 total
    fu.disabledUntilFu      = 0;   // reload timestamp
  });

  
  // â”€â”€ Point every radar EXACTLY away from B/E â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   statics.forEach(s => {
   if (s.type === 'rad') {
     // direct bearing from B/E to radar gives the "away" direction
     s.wedgeDir = bearing(bullseye, s);
 // 2) new animation state
 s.disabledUntil = 0;     // when its red disable expires
      s.animFrom      = null;  // starting direction for animation
      s.animTo        = null;  // target direction
      s.animStart     = 0;     // timestamp when animation began
    }
  });
}

/* â”€â”€â”€ MISSION LOG (auto-captured) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const MISSION_LOG = [];            // { z:'HH:MM:SSZ', msg:'â€¦' }

function recordLog(msg) {
  msg = msg.trim();
  if (!msg) return;                // ignore blanks
  const z = new Date().toISOString().slice(11, 19) + 'Z';
  MISSION_LOG.push({ z, msg });

    // â”€â”€ announce special events immediately â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const lower = msg.toLowerCase();
  let m;
  if ((m = lower.match(/track\s+(\d{5})\s+vanished\b/))) {
    const id = m[1];  // â† grab the code
   // penalty only if Birds Away was never communicated
   const trk = tracks.find(t => t.id === id);
    if (trk && !trk._communicatedAway && !trk._contractViolated) {
      changeScore(-0.5, 'Contract Violation: Did not communicate BIRDS AWAY via [W] hotkey');
      trk._contractViolated = true;
      // also log the violation in the mission log
      const z2 = new Date().toISOString().slice(11,19) + 'Z';
      MISSION_LOG.push({
        z:   z2,
        msg: 'Contract Violation: Did not communicate BIRDS AWAY via [W] hotkey'
      });
    }
  }
}

/* 1 observer instance that we reuse for both elements */
const logObserver = new MutationObserver(muts => {
  muts.forEach(m => recordLog(m.target.textContent.trim()));
});

/* start watching both on-screen â€œchatâ€ areas */
logObserver.observe(statusEl,   { childList:true, subtree:true, characterData:true });
logObserver.observe(feedbackEl, { childList:true, subtree:true, characterData:true });


/**
 * Decide which missile type to fire (based on range), consume 2 rounds,
 * decrement engagementsRemaining, and handle reload warnings/outage.
 * Returns `true` if you SHOULD fire, `false` if blocked/reloading.
 */
 function processPatriotEngagement(fu, rangeNm) {
  const now   = Date.now();
  const label = getFuLabel(fu);

  

  // 1) If currently reloading â†’ block
  if (now < fu.disabledUntilFu) {
    const mins = Math.ceil((fu.disabledUntilFu - now) / 60000);
    const msg  = `ADAFCO, TD, CANTCO, ${label} Reload, ETIC ${mins}â€¯min`;
    statusEl.textContent   = msg;
    feedbackEl.textContent = msg;
    return false;
  }

  // 2) Pick preferred type by range
  let order;
  if (rangeNm < 40)         order = ['pac3','mse','pac2'];
  else if (rangeNm <= 60)   order = ['mse','pac3','pac2'];
  else                       order = ['pac2','mse','pac3'];

  let chosen;
  for (const t of order) {
    if (fu.ammo[t] >= 2) { chosen = t; break; }
  }

  // 3) If none available â†’ start reload
  if (!chosen) {
    fu.disabledUntilFu = now + 15*60*1000;
    const mins = Math.ceil((fu.disabledUntilFu - now) / 60000);
    const msg  = `ADAFCO, TD, CANTCO, ${label} Reload, ETIC ${mins}â€¯min`;
    statusEl.textContent   = msg;
    feedbackEl.textContent = msg;
    // refill after 15â€¯min
    setTimeout(() => {
      fu.engagementsRemaining = 28;
      fu.ammo = { pac2:12, pac3:32, mse:12 };
    }, 15*60*1000);
    return false;
  }

  // 4) Consume 2 of that type & one engagement
  fu.ammo[chosen]         -= 2;
  fu.engagementsRemaining -= 1;

  // stats
  STATS.missilesUsed[chosen] += 2;
  // 5) Warnings at thresholds
  if (fu.engagementsRemaining === 10) {
    feedbackEl.textContent = `ADAFCO, TD, ${label} Weapons Yellow`;
  } else if (fu.engagementsRemaining === 4) {
    feedbackEl.textContent = `ADAFCO, TD, ${label} Weapons Red`;
  }

  return true;
}


 // â”€â”€â”€ TRACKS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const rand = (a,b)=>Math.floor(Math.random()*(b-a)+a);

// â”€â”€â”€ TRACK SPAWNING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function newTrack() {
  const minSpawnNm = 60,
        maxSpawnNm = 170;

  let x, y, heading, spawnDistNm, radius, ang;

  // keep trying until the final (wrapped) point is â‰¥50â€¯NM from bullseye
  do {
    // 1) random direction
    ang = Math.random() * 2 * Math.PI;

    // 2) random distance between 50â€“170â€¯NM
    spawnDistNm = Math.random() * (maxSpawnNm - minSpawnNm) + minSpawnNm;
    radius      = spawnDistNm / CFG.nmPerPixel;

    // 3) compute raw world coords around bullseye
    x = bullseye.x + Math.cos(ang) * radius;
    y = bullseye.y + Math.sin(ang) * radius;

// 4) keep the real world coordinates â€” no wrapping on small screens

    // loop until that wrapped point really is â‰¥50â€¯NM away
  } while (distNm(bullseye, { x, y }) < minSpawnNm);

    // 5) start with a random roaming heading (0â€‘359Â°)
    heading = Math.floor(Math.random() * 360);

  // 6) altitude and speed as before
  const alt = rand(5, 600);
  let speed;
  if (alt <= 150)         speed = rand(250, 500);
  else if (alt <= 300)    speed = rand(400, 600);
  else                    speed = rand(500, 700);

  return {
    id:           ('00000' + rand(1000, 7776)).slice(-5),
    x, y,
    heading,
    speed,
    destAlt:      0,
    friendly:     false,
    alt,
    tag:          null,
    tagTime:      0,
    destroyed:    false,
    everEngaged:  false
  };
  return {
  // â€¦ existing props â€¦
  bombLaunched10: false,
  bombLaunched5:  false,   // <- track whether itâ€™s already dropped its bomb
};

}
/**
 * Returns the â€œNE Quadrantâ€, â€œSW Quadrantâ€, etc., for a track
 * based on its closest Patriot FU or NASAMS ring.
 */
 function getQuadrant(track) {
  const fu = closestFu(track);
  // getFuLabel(fu) returns e.g. "NE PATRIOT" or "SE NASAMS"
  const hemi = getFuLabel(fu).split(' ')[0];
  return `${hemi} Quadrant`;
}

/** 
 * Returns zeroâ€‘padded bearing/distance string like "123/45"
 */
function formatBE(track) {
  const b = ('000' + bearing(bullseye, track)).slice(-3);
  const r = distNm(bullseye, track);
  return `${b}/${r}`;
}

/**
 * Tag the given track and any other hostiles within 5â€¯NM as ENGAGE.
 * @param {object} mainTrack â€“ the track the SL just engaged
 * @returns {Array<object>}  â€“ the array of all tracks just engaged
 */
 function engageCluster(mainTrack) {
  const now     = Date.now();
  // find all hostiles (not friendly, not destroyed) within 5â€¯NM of mainTrack
  const cluster = tracks.filter(t =>
    !t.friendly &&
    !t.destroyed &&
    t !== mainTrack &&
    distNm(mainTrack, t) <= 5
  );
  // always include the main track itself
  const all = [ mainTrack, ...cluster ];
  all.forEach(t => {
    t.tag      = 'ENGAGE';
    t.tagTime  = now;
    t.everEngaged = true;      // if you want to prevent ROE penalties later
  });
  return all;
}

// Helper to label each FU by quadrant
function getFuLabel(fu) {
  const dx = fu.x - bullseye.x,
        dy = fu.y - bullseye.y;
  const hemiNS = dy < 0 ? 'N' : 'S',
        hemiEW = dx < 0 ? 'W' : 'E';
  return `${hemiNS}${hemiEW} PATRIOT`;
}


function initTracks () {
  tracks = Array.from({ length: CFG.trackCount }, newTrack);
  updateVisibility();          // first pass for splash-screen
}
initTracks();

function spawnTbmWave() {
  const now = Date.now();
  const icc = statics.find(s => s.type === 'icc');

  // 1) spacing & cluster geometry
  const sideNm    = 5;                       // ~5â€¯NM between each TBM
  const offsetNm  = sideNm / Math.sqrt(3);   // centroid â†’ vertex distance
  const minC      = 130 + offsetNm;          
  const maxC      = 140 - offsetNm;          
  const clusterR  = Math.random() * (maxC - minC) + minC;
  const clusterAng= Math.random() * 2 * Math.PI;
  // cluster center in world pixels
  const cx = icc.x + Math.cos(clusterAng) * (clusterR / CFG.nmPerPixel);
  const cy = icc.y + Math.sin(clusterAng) * (clusterR / CFG.nmPerPixel);

  // 2) orientation of the triangle (random rotation)
  const rot = Math.random() * 2 * Math.PI;
  const dPx = offsetNm / CFG.nmPerPixel;

  // 3) build the three TBMs
    const wave = {
  spawn:        now,
    impact:       null,
    resolved:     false,
    fireballArmed:false,   // â† NEW: will be set when Fireball pressed
    tbms:         []
  };
  for (let i = 0; i < 3; i++) {
    const ang = rot + (i * 2 * Math.PI / 3);  // 0Â°, 120Â°, 240Â°
    const x   = cx + Math.cos(ang) * dPx;
    const y   = cy + Math.sin(ang) * dPx;
    const heading      = bearing({ x, y }, icc);
    const speed        = CFG.tbmSpeedKts;
    // true distance from ICC in NM (for impact time)
    const distFromIcc  = Math.hypot(x - icc.x, y - icc.y) * CFG.nmPerPixel;
    const timeToImpact = (distFromIcc / speed) * 3600 * 1000;

    const t = {
  id: `TBM${i+1}`,
  x, y,
  heading,
  speed,
  alt: CFG.tbmAltitude,
  destAlt: 0,
  tag: null,
  destroyed: false,
  everEngaged: false,
  isTbm: true,
  // â† NEW:
  patriotFired: false,
  NASAMSFired:   false, 
  cratered:     false
    };

    // schedule impact penalty if not resolved
   tracks.push(t);
    wave.tbms.push(t);
  }

  // 4) enable FIREBALL
  tbmWaves.push(wave);
  fireballBtn.disabled = false;
  CFG.tbmWindowMs     = wave.impact - now;
}

function engageTbmWithPatriot(tbm) {
  const fu = closestFu(tbm);
  const d  = distNm(fu, tbm);
  if (!processPatriotEngagement(fu, d)) return;
  const speedPxPerSec = (5000/3600)/CFG.nmPerPixel;
  [0, 1000].forEach(offset => {
    setTimeout(() => {
      if (!tbm.destroyed) {
        missiles.push({
          x: fu.x,
          y: fu.y,
          target: tbm,
          fu,
          speedPxPerSec,
          expire: Date.now() + 15000
        });
      }
    }, offset);
  });
  // schedule the impact check just like AWAY
  scheduleImpactCheck(tbm);
}

function engageTbmWithNASAMS(tbm) {
  const nas = statics.find(s => s.id === 'NASAMS');
  const now = Date.now();

  // 1) If weâ€™re still in reload, block
  if (now < NASAMSDisabledUntil) {
    const mins = Math.ceil((NASAMSDisabledUntil - now) / 60000);
    const msg  = `ADAFCO, TD, NASAMS reload ETIC ${mins}â€¯min`;
    statusEl.textContent   = msg;
    feedbackEl.textContent = msg;
    return;
  }

  // 2) If fewer than 2 remain, start reload
 if (NASAMSMissiles <= 1) {
    NASAMSDisabledUntil = now + 15 * 60 * 1000;
    const mins = Math.ceil((NASAMSDisabledUntil - now) / 60000);
    const msg  = `ADAFCO, TD, NASAMS reload ETIC ${mins}â€¯min`;
    statusEl.textContent   = msg;
    feedbackEl.textContent = msg;
    setTimeout(() => { NASAMSMissiles = 18; }, 5 * 60 * 1000);
    return;
  }

    // 3) Consume two AIMâ€‘120s then launch two missiles, 1s apart
  NASAMSMissiles -= 2;
  STATS.missilesUsed.aim120 += 2;
  [0, 1000].forEach(offset => {
    setTimeout(() => {
      if (!tbm.destroyed) {
        missiles.push({
          x:             nas.x,
          y:             nas.y,
          target:        tbm,
          fu:            nas,
          speedPxPerSec: (5000/3600) / CFG.nmPerPixel,
          expire:        Date.now() + 15000
        });
      }
    }, offset);
  });
  scheduleImpactCheck(tbm);
 }




const fireballBtn = document.getElementById('fireballBtn');

 // always keep the button enabled
fireballBtn.disabled = false;

// arm all waves & give instant feedback
fireballBtn.addEventListener('click', () => {
  // 1) arm every pending TBM wave
  tbmWaves.forEach(w => w.fireballArmed = true);

  // 2) immediate UI callâ€‘out
  statusEl.textContent   = 'Crew, ADAFCO, FIREBALL FIREBALL FIREBALL!';
  feedbackEl.textContent = 'Crew, ADAFCO, FIREBALL FIREBALL FIREBALL!';
});

/**
 * Unified visibility gate.  
 * A track is selectable / hoverable / taggable iff
 *   â€“ it isnâ€™t destroyed **and**
 *   â€“ the coverage scanner hasnâ€™t marked it â€œhiddenâ€.
 * `t._visible` is *undefined* until the first scan â†’ treat that as **true**
 */
function isTrackVisible(t){
  return !t.destroyed && (t._visible !== false);
}

    // â”€â”€â”€ UTILS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const d2r = d=>d*Math.PI/180;
    function bearing(a, b) {
  // 1) raw angle in [0 â€¦ 360)
  const raw = (Math.atan2(b.x - a.x, a.y - b.y) * 180 / Math.PI + 360) % 360;
  // 2) always round *up* any fraction
  let deg = Math.ceil(raw);
  // 3) map exact 0 â†’ 360 so you stay in 1â€“360
  if (deg === 0) deg = 360;
  return deg;
}

    function distNm(a,b){
      return Math.round(Math.hypot(a.x-b.x,a.y-b.y)*CFG.nmPerPixel);
    }
    function scrToWorld(sx,sy){
      return { x: offX + sx/scale, y: offY + sy/scale };
    }
    function distTouch(t0,t1){
      return Math.hypot(t0.clientX-t1.clientX, t0.clientY-t1.clientY);
    }
/**
 * Returns true if track `t` lies within the 80 NM / Â±60Â° wedge of radar `s`. 
 * This allows room for missiles with longer legs to still impact
 */
 function insideWedge(s, t) {
  const dx = (t.x - s.x) * CFG.nmPerPixel;
  const dy = (t.y - s.y) * CFG.nmPerPixel;
  const d  = Math.hypot(dx, dy);
  if (d > 80) return false;

  const Î¸  = (s.wedgeDir - 90) * Math.PI/180;
  const ax = Math.cos(Î¸);
  const ay = Math.sin(Î¸);

  const dot = (dx*ax + dy*ay) / d;

  // inside Â±60Â° if dot â‰¥ cos(60Â°) = 0.5
  return dot >= 0.5;
}

/* â”€â”€â”€ Missileâ€‘inâ€‘flight helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/** Return the FU (PATRIOT or NASAMS) closest to this track. */
function closestFu(track) {
  return statics
    .filter(s => s.type === 'fu')                    // PATRIOT launchers + NASAMS
    .reduce((best, s) =>
      !best || distNm(s, track) < distNm(best, track) ? s : best, null);
}

/** Schedule the â€œkill / trashedâ€ assessment at the computed impact time. */
function scheduleImpactCheck(t) {
  // 0) if we already scheduled one (reâ€‘shot), cancel it
  if (t.mslTimer) clearTimeout(t.mslTimer);

  // 1) pick launch site & basic kinematics
  const fu   = closestFu(t);
  const dx   = (t.x - fu.x) * CFG.nmPerPixel;    // Î” in NM
  const dy   = (t.y - fu.y) * CFG.nmPerPixel;
  const dist = Math.hypot(dx, dy);               // LOS range (NM)

  const Vt   = t.speed;                          // kts
  const Î¸t   = d2r(t.heading);
  const vtx  = Math.sin(Î¸t) * Vt;                // NMâ€¯/â€¯hr components
  const vty  = -Math.cos(Î¸t) * Vt;

  const uX   = dx / dist;                        // LOS unitâ€‘vector
  const uY   = dy / dist;
  const Vm   = 3000;                             // missile speed (kts)

  // 2) closure speed along LOS
  const closure = Vm - (vtx * uX + vty * uY);    // NMâ€¯/â€¯hr
  if (closure <= 0) {
    // missile can never overtake â†’ treat as immediate trashed
    markShotTrashed(t);
    return;
  }

  const tHr   = dist / closure;                  // hours to intercept
  const tMs   = tHr * 3600 * 1000;               // â†’ ms

  // 3) future impact coordinates (worldâ€‘px)
  const ipX = t.x + (vtx / 3600) * tMs / CFG.nmPerPixel;
  const ipY = t.y + (vty / 3600) * tMs / CFG.nmPerPixel;

  // âœ¦ record exactly **when** that intercept will happen
t.interceptTimestamp = Date.now() + tMs;

  // 4) schedule the decision
  t.mslTimer = setTimeout(() => impactDecision(t), tMs);
}

/** Decide at impact whether the bird killed (+1) or trashed (â€“1 & ENGAGE). */
function impactDecision(track) {
  if (track.destroyed) return;

  // use the trackâ€™s real worldâ€‘px position at this instant:
  const ix = track.x, 
        iy = track.y;

  const now = Date.now();

  /* A)  check NASAMS ring â€” 15â€¯NM around the NASAMS FU */
  const NASAMS = statics.find(s => s.id === 'NASAMS');
  const inRing = NASAMS && distNm({x:ix,y:iy}, NASAMS) <= 15;

    // B) geometry check (ignores reload/red status)
  const inAnyWedgeGeom = statics
    .filter(s => s.type === 'rad')
    .some(rad => insideWedge(rad, { x: ix, y: iy }));

  // C) â€œactiveâ€ wedge for launchâ€“blocking elsewhere
  const inAnyWedgeBlocked = statics
    .filter(s => s.type === 'rad' &&
                 now >= s.disabledUntil &&
                 s.animFrom == null)
    .some(rad => insideWedge(rad, { x: ix, y: iy }));

       // â”€â”€â”€ FRIENDLY IMPACT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (track.friendly) {
    // only inside geometry is fratricide
    if (inRing || inAnyWedgeGeom) {
      changeScore(-20, 'Fratricide! â€“20 points');
      STATS.fratricide++;
  STATS.impacts.push(`Fratricide on friendly ${track.id}`);
    } else {
      // outside geometry: birds trashed + ROE
        // only levy the ROE penalty when REDWOOD isnâ€™t hot in this quadrant
  if ( roePenaltyAllowed(t) ) {
      changeScore(-6, 'BIRDS TRASHED: â€“1; ROE Violation: â€“5');
     
       if (!t._outcomeLogged) {
   t._outcomeLogged = true;
   STATS.engagementsBad++;
STATS.roeViolations++;
  }
  }}
    track.destroyed = true;
    return;
  }

  // check if this position lies inside any Patriot wedge
const covering = statics
  .filter(s => s.type==='rad' && s.system==='MPQâ€‘53')
  .filter(r => insideWedge(r, { x:ix, y:iy }));

// if any cover exists but _all_ are disabled or animating, trash:
if (covering.length &&
    covering.every(r => now < r.disabledUntil || r.animFrom != null)
) {
  markShotTrashed(track);
  return;
}

   // ---------------- VALID kill ----------------
if (inRing || inAnyWedgeGeom) {
  // 1) score the kill
  changeScore(1, `Track ${track.id} Vanished: +1`);
  radioSay(`${ADAFCO}, ${ICC}, Splash track ${track.id}.`);
    if (!track._outcomeLogged) {
    track._outcomeLogged = true;
    STATS.engagementsGood++;
  }

// 2) fratricide check: for nonâ€‘TBM, nonâ€‘Cruise kills
if (!track.isTbm && !track.isCruise) {
  console.log(`â˜ ï¸ Valid kill of ${track.id} â€” checking friendlies`);
  tracks.forEach(f => {
     if (f.friendly && !f.destroyed) {
      const d = distNm(f, track);
      console.log(`   â€¢ friendly ${f.id} is ${d}â€¯NM away`);
      if (d <= 5) {
        console.log(`   â†’ FRATRICIDE: destroying ${f.id}`);
            f.destroyed  = true;
            f.tag        = null;     // clear any lingering tag
            f._visible   = false;    // force it off the screen immediately
        changeScore(-20, `Fratricide! Friendly ${f.id} within ${d}â€¯NM of ${track.id}`);
      }
    }
  });
}

  // 3) vanish the bird
  track.destroyed = true;
  track.tag       = null;

  // 4) advance the queue
  nextQueueTrack();

  // 5) levelâ€‘complete?
  const hostilesLeft = tracks.some(t =>
    !t.destroyed && !t.friendly && !t.isTbm
  );
  if (!hostilesLeft) {
    showLevelComplete();
    resetRedwood();

  }

} else {
  // ---------------- TRASHED ----------------
  markShotTrashed(track);
}

}

/** Apply the trashed penalty & revert to ENGAGE at current position. */
function markShotTrashed(t) {
  
  if (!t._outcomeLogged) {
   t._outcomeLogged = true;
    STATS.engagementsBad++;
    changeScore(-1, `BIRDS TRASHED Track ${t.id}: -1 point`);
  speakFast(`${ADAFCO}, ${ICC}, birds trashed track ${t.id}.`);
  }
  
  t.tag           = 'ENGAGE';
  t.tagTime       = Date.now();
  t.everEngaged   = true;
  const be = ('000' + bearing(bullseye, t)).slice(-3);
  statusEl.textContent =
    `ADAFCO, SL, ENGAGE Track ${t.id}, B/E ${be}/${distNm(bullseye,t)}`;
}

   // â”€â”€â”€ UTILS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function nmToPx(nm) {
  return nm / CFG.nmPerPixel;
}
function drawCircle(ctx, p, radiusNm) {
  const rpx = nmToPx(radiusNm);
  ctx.save();
  ctx.beginPath();
  // use the same yellow youâ€™ve defined in :root
  ctx.fillStyle = 'rgba(255,214,10,0.1)';
  ctx.arc(p.x, p.y, rpx, 0, 2 * Math.PI);
  ctx.fill();
  ctx.restore();
}

function drawWedge(ctx, p, startDeg, endDeg, radiusNm) {
  const rpx = nmToPx(radiusNm);
  ctx.save();
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,214,10,0.1)';
  // 0Â°=north, 90Â°=east â†’ subtract 90 to get canvas 0 at +x
  const toRad = d => (d - 90) * Math.PI/180;
  ctx.moveTo(p.x, p.y);
  ctx.arc(p.x, p.y, rpx, toRad(startDeg), toRad(endDeg), false);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function damageLauncherAmmo (fu) {
  /* â€” NASAMS â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
  if (fu.id === 'NASAMS') {
    const lost = Math.ceil(NASAMSMissiles * 0.33);       // 33 %
    NASAMSMissiles = Math.max(0, NASAMSMissiles - lost);
    feedbackEl.textContent = `NASAMS launcher damaged â€“ lost ${lost} AIM-120s`;
    STATS.impacts.push(`NASAMS lost ${lost} AIMâ€‘120s`);
    return;
  }

  /* â€” Patriot FU â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
  const bundleLoss = { pac2: 4, mse: 12, pac3: 16 };
  const choices    = Object.keys(bundleLoss).filter(t => fu.ammo[t] > 0);
  if (!choices.length) return;        // nothing left to lose

  const pick = choices[Math.floor(Math.random() * choices.length)];
  const lost = bundleLoss[pick];
  fu.ammo[pick] = Math.max(0, fu.ammo[pick] - bundleLoss[pick]);

  // engagementsRemaining = total rounds Ã· 2
  fu.engagementsRemaining = Math.max(
    0,
    Math.floor((fu.ammo.pac2 + fu.ammo.mse + fu.ammo.pac3) / 2)
  );

  feedbackEl.textContent =
    `${getFuLabel(fu)} damaged â€“ lost ${bundleLoss[pick]} ${pick.toUpperCase()}`;
    STATS.impacts.push(`${getFuLabel(fu)} lost ${lost} ${pick.toUpperCase()} missiles`);
}

    // â”€â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function drawCompass(){
      if(!compassOn) return;
      ctx.save();
      ctx.strokeStyle = 'rgba(200,200,200,0.7)';
      ctx.lineWidth = 1;
      const x = bullseye.x, y = bullseye.y;
      const maxRpx = CFG.maxSpawnNm / CFG.nmPerPixel;
      [0, Math.PI/2, Math.PI, 3*Math.PI/2].forEach(angle=>{
        const x2 = x + Math.cos(angle)*maxRpx;
        const y2 = y + Math.sin(angle)*maxRpx;
        ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();
      });
      [50,100,150].forEach(rnm=>{
        const rpx = rnm / CFG.nmPerPixel;
        ctx.beginPath(); ctx.arc(x,y,rpx,0,2*Math.PI); ctx.stroke();
      });
      ctx.restore();
    }

    // â”€â”€â”€ ADD THESE TWO HELPERS ANYWHERE ABOVE your animate() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function firePatriotAt(tbm) {
  const fu = closestFu(tbm);
  const speedPxPerSec = (5000/3600)/CFG.nmPerPixel;
  // launch two missiles, 1â€¯s apart
  [0, 1000].forEach(offset =>
    setTimeout(() => {
      if (!tbm.destroyed) {
        missiles.push({
          x:             fu.x,
          y:             fu.y,
          target:        tbm,
          fu,
          speedPxPerSec,
          expire:        Date.now() + 15_000
        });
      }
    }, offset)
  );
}
   // â”€â”€â”€ DRAW STATICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Remove any global wedge here! Just draw icons/text.
function drawStatics() {
  const colICC = getComputedStyle(document.documentElement).getPropertyValue('--icc');

  statics.forEach(s => {
 
        /* â”€â”€â”€ PATRIOT radar wedge & dish â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        if (s.type === 'rad') {
  const now = Date.now();

  // 1) compute current pointing direction (animated if rotating)
  let dir;
  if (s.animFrom != null) {
    const pct   = Math.min((now - s.animStart) /
                           (s.disabledUntil - s.animStart), 1);
    const delta = ((s.animTo - s.animFrom + 540) % 360) - 180;
    dir = s.animFrom + delta * pct;
    if (pct >= 1) {
      s.wedgeDir = s.animTo;
      s.animFrom = s.animTo = null;
    }
  } else {
    dir = s.wedgeDir;
  }

  // 2) determine cosmetic wedge color:
  //    - red for forced outage
  //    - orange for FU reload
  //    - yellow otherwise
  const fus = statics.filter(x => x.type === 'fu');
  const pairedFu = fus.reduce((best, f) =>
    !best || distNm(f, s) < distNm(best, s) ? f : best,
  null);

  const isOutage = now < s.disabledUntil;
  const isReload = pairedFu && now < pairedFu.disabledUntilFu;
  let fillColor;
  if (isOutage)       fillColor = 'rgba(255,0,0,0.1)';
  else if (isReload)  fillColor = 'rgba(255,165,0,0.1)';
  else                fillColor = 'rgba(0,255,0,0.1)';     // green when active

  // 3) draw the 60â€¯NM Â±60Â° wedge with that color
  ctx.save();
    ctx.fillStyle = fillColor;
    const halfDeg = 60, radNm = 60;
    const toRad = d => (d - 90) * Math.PI / 180;
    ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.arc(
        s.x, s.y,
        nmToPx(radNm),
        toRad(dir - halfDeg),
        toRad(dir + halfDeg),
        false
      );
      ctx.closePath();
      ctx.fill();
  ctx.restore();

/* 4) Patriot radar symbol â€“ 50 % smaller version */
ctx.save();
  ctx.translate(s.x, s.y);
  ctx.lineJoin = ctx.lineCap = 'round';

/* uniform scale factor â€” 0.25 = 75 % smaller (keeps maths tidy) */
const SCALE = 0.5;

/* â”€â”€ geometry (base values Ã— SCALE) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const BASE_W  = 10  * SCALE,
      BASE_H  =  3  * SCALE,
      TOWER_H = 10  * SCALE,
      TOWER_W =  8  * SCALE,
      DISH_R  =  8  * SCALE,
      TILT    = -35 * Math.PI / 180;   // unchanged

/* â”€â”€ colours & stroke width â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const CLR_DISH   = '#5a5a5a',
      CLR_TRUSS  = '#4a4a4a',
      CLR_BASE   = '#3c3c3c',
      CLR_STROKE = '#202020';

ctx.lineWidth = 1.2 * SCALE;

/* â”€â”€ base block â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
ctx.fillStyle = CLR_BASE;
ctx.fillRect(-BASE_W/2, -BASE_H, BASE_W, BASE_H);

/* â”€â”€ truss legs & braces â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
ctx.fillStyle   = CLR_TRUSS;
ctx.strokeStyle = CLR_STROKE;

/* side legs */
ctx.beginPath();
  ctx.moveTo(-TOWER_W/2, -BASE_H);
  ctx.lineTo( 0,          -BASE_H - TOWER_H);
  ctx.lineTo( TOWER_W/2, -BASE_H);
ctx.closePath();
ctx.fill();

/* X-braces */
ctx.beginPath();
  ctx.moveTo(-TOWER_W/2,        -BASE_H);
  ctx.lineTo( TOWER_W/2, -BASE_H - TOWER_H);
  ctx.moveTo( TOWER_W/2,        -BASE_H);
  ctx.lineTo(-TOWER_W/2, -BASE_H - TOWER_H);
ctx.stroke();

/* small mounting plate */
ctx.beginPath();
  ctx.moveTo(-3 * SCALE, -BASE_H - TOWER_H);
  ctx.lineTo( 3 * SCALE, -BASE_H - TOWER_H);
ctx.stroke();

/* â”€â”€ dish & feed-horn â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
ctx.save();
  ctx.translate(0, -BASE_H - TOWER_H);
  ctx.rotate(TILT);

  /* concave side faces feed-horn */
  ctx.fillStyle   = CLR_DISH;
  ctx.beginPath();
    ctx.arc(0, 0, DISH_R, -Math.PI/2, Math.PI/2, false);
    ctx.lineTo(0, 0);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  /* feed-horn stub */
  const hx = DISH_R * 0.6;
  ctx.beginPath();
    ctx.moveTo(hx, 0);
    ctx.lineTo(hx + 4 * SCALE, 0);
  ctx.stroke();
  ctx.beginPath();
    ctx.arc(hx + 4 * SCALE, 0, 1.5 * SCALE, 0, Math.PI * 2);
  ctx.fillStyle = CLR_STROKE;
  ctx.fill();
ctx.restore();   // leave dish rotation

ctx.restore();   // leave icon transform

}

/* â”€â”€â”€ TPS-75 planar-array radar with animated sweep â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
 else if (s.type === 'c2Rad') {
  const now = Date.now();

  /* â”€â”€ init + 6 RPM sweep angle (unchanged) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  if (s._spinLast == null) { s._spinLast = now; s._spinAngle = 0; }
  const active  = now >= (s.disabledUntil || 0) && s.animFrom == null;
  const Î”ms     = now - s._spinLast;
  s._spinLast   = now;
  if (active) {
    // 6 rev/min  â†’  360Â° Ã—6 / 60 s  =  36 Â°/s  â†’  0.036 Â°/ms
    s._spinAngle = (s._spinAngle + Î”ms * 0.036) % 360;
  }

  /* â”€â”€ geometry / colours â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const W = 8, H = 6;               // panel width / height  (px)
  const PADDING = 2;                  // border inset
  const STEM_H  = 4;                  // support-stem length
  const FOOT_W  = 4;                  // half length of the horizontal foot

const CLR_FILL   = '#2f3a33';   // darker, muted green face
const CLR_FRAME  = '#1f2421';   // very dark frame
const CLR_SWEEP  = '#4f7a53';   // deeper, subdued sweep bar
const CLR_BASE   = '#1f2433';   // match the frame for supports

  /* â”€â”€ 1) planar array panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  ctx.save();
    ctx.fillStyle   = CLR_FILL;
    ctx.strokeStyle = CLR_FRAME;
    ctx.lineWidth   = 1;

    // filled face
    ctx.fillRect(s.x - W/2, s.y - H/2, W, H);

    // frame border
    ctx.strokeRect(s.x - W/2, s.y - H/2, W, H);
  ctx.restore();

  /* â”€â”€ 2) animated sweep bar (slides across face) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  // convert 0â€“360Â° sweepAngle to 0â€“W movement Lâ†’R
  const sweepX = ((s._spinAngle / 360) * (W - 2*PADDING)) - (W/2 - PADDING);

  ctx.save();
    ctx.strokeStyle = CLR_SWEEP;
    ctx.lineWidth   = 1;

    ctx.beginPath();
      ctx.moveTo(s.x + sweepX,        s.y - H/1.5 + PADDING);
      ctx.lineTo(s.x + sweepX,        s.y + H/1.5 - PADDING);
    ctx.stroke();
  ctx.restore();

  /* â”€â”€ 3) upside-down-T support mast (unchanged size) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  ctx.save();
    ctx.strokeStyle = CLR_BASE;
    ctx.lineWidth   = 1.5;

    const baseX = s.x;
    const baseY = s.y + H / 1.8;

    // vertical stem
    ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(baseX, baseY + STEM_H);
    ctx.stroke();

    // horizontal foot
    ctx.beginPath();
      ctx.moveTo(baseX - FOOT_W, baseY + STEM_H);
      ctx.lineTo(baseX + FOOT_W, baseY + STEM_H);
    ctx.stroke();
  ctx.restore();
}


/* â”€â”€â”€ SENTINEL radar â€“ mini truck + planar array â”€â”€â”€â”€â”€â”€â”€ */
 else if (s.type === 'sentinel') {
  /* 1 â”€ 15 NM engagement ring (unchanged) */
  const now      = Date.now();
    const disabled =
      /* â‘  explicit status flag */   (typeof s.status === 'string' &&
                                       s.status.toLowerCase() !== 'active') ||
      /* â‘¡ boolean active flag  */   (s.hasOwnProperty('active') && !s.active) ||
      /* â‘¢ timed-out downtime  */    now < (s.disabledUntil || 0);
  ctx.save();
    ctx.fillStyle = disabled
      ? 'rgba(255,0,0,0.1)'
      : 'rgba(0,255,0,0.1)';
    ctx.beginPath();
    ctx.arc(s.x, s.y, nmToPx(15), 0, Math.PI * 2);
    ctx.fill();
  ctx.restore();
  /* panel sweep angle (re-use _spinAngle) */
  if (s._spinLast == null) { s._spinLast = now; s._spinAngle = 0; }
  const active = now >= s.disabledUntil;
  const dMs    = now - s._spinLast;
  s._spinLast  = now;
  if (active) s._spinAngle = (s._spinAngle + dMs * 0.05) % 360;   // ~8 RPM

  const SCALE = 0.40;                // keeps it small
  const B   = 14 * SCALE, H =  4 * SCALE;   // truck bed
  const CAB =  4 * SCALE;
  const WHEEL = 1.5 * SCALE;
  const PNL_W = 5 * SCALE, PNL_H =  6 * SCALE;

  ctx.save();
  ctx.translate(s.x, s.y);

  /* truck bed */
  ctx.fillStyle = '#303030';
  ctx.fillRect(-B/2, -H/2, B, H);
  /* cab */
  ctx.fillStyle = '#404040';
  ctx.fillRect( B/2 - CAB, -H/2, CAB, H);
  /* wheels (pair) */
  ctx.fillStyle = '#0a1a1a';
  [-B*0.25, B*0.15].forEach(x => {
    ctx.beginPath(); ctx.arc(x, H/2 + WHEEL, WHEEL, 0, Math.PI*2); ctx.fill();
  });

  /* planar array panel */
  ctx.save();
    ctx.translate(-B/2 + 2*SCALE, -H/2);      // just behind cab
    ctx.rotate(-20 * Math.PI/180);            // slight tilt
    ctx.fillStyle   = '#505c4f';
    ctx.strokeStyle = '#323d37';
    ctx.lineWidth   = 0.3;
    ctx.fillRect(0, -PNL_H, PNL_W, PNL_H);
    ctx.strokeRect(0, -PNL_H, PNL_W, PNL_H);

    /* moving sweep bar */
    const xOff = (s._spinAngle/360) * (PNL_W-4) + 2;
    ctx.strokeStyle = '#505050';
    ctx.beginPath();
      ctx.moveTo(xOff, -PNL_H+2);
      ctx.lineTo(xOff, -2);
    ctx.stroke();
  ctx.restore();

  ctx.restore();

  /* grey-out when disabled */
  if (now < s.disabledUntil) {
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(s.x-PNL_W/2, s.y-PNL_H-H/2, PNL_W, PNL_H+H);
  }}

    
/* â”€â”€â”€ NASAMS launcher â€“ simple 1-tube pack split in half â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
 else if (s.id === 'NASAMS') {
ctx.save();
  ctx.translate(s.x, s.y);

  /* â€” 50% scaled constants â€” */
  const TRUCK_L   =  6;      // was 16
  const TRUCK_H   =  1.5;      // was 4
  const CAB_L     =  1.5;      // was 4
  const SMALL_R   = 0.60;    // was 1.5
  const LAUNCH_L  = 3.5;     // was 13
  const LAUNCH_H  = 1.5;     // was 3
  const ARM_LEN   = 2.5;     // was 7
  const ELEVATE   = -45 * Math.PI / 180;

  /* â€” body â€” */
  ctx.fillStyle = '#505c4f';
  ctx.fillRect(-TRUCK_L/2, -TRUCK_H/2, TRUCK_L, TRUCK_H);

  /* â€” cab â€” */
  ctx.fillStyle = '#323d37';
  ctx.beginPath();
    ctx.moveTo( TRUCK_L/2 - CAB_L, -TRUCK_H/2);
    ctx.lineTo( TRUCK_L/2,          -TRUCK_H/2);
    ctx.lineTo( TRUCK_L/2,           TRUCK_H/2);
    ctx.lineTo( TRUCK_L/2 - CAB_L,   TRUCK_H/2);
  ctx.closePath();
  ctx.fill();

  /* â€” wheels (two pairs) â€” */
  ctx.fillStyle = '#323d37';
  const axleOff = TRUCK_L * 0.3;
  const pairGap = SMALL_R * 0.5 + 0.5;
  const wheelY  = TRUCK_H/2 + SMALL_R;
  const xs = [
    -axleOff - pairGap/2,
    -axleOff + pairGap/2,
     axleOff - pairGap/2,
     axleOff + pairGap/2
  ];
  xs.forEach(x => {
    ctx.beginPath();
    ctx.arc(x, wheelY, SMALL_R, 0, Math.PI*2);
    ctx.fill();
  });

/* â€” launcher canister (3 tubes stacked) â€” */
const pivotX = -TRUCK_L / 2 + 1;   // hinge on the trailer
const pivotY = -TRUCK_H / 2;
ctx.save();
  ctx.translate(pivotX, pivotY);
  ctx.rotate(ELEVATE);

  /* â†‘-â†“ thickness is larger; length stays the same */
  const PACK_L = LAUNCH_L;        // keep previous length (â‰ˆ6.5)
  const PACK_H = 3.0;             // â†‘ taller â‡’ looks â€œwiderâ€ in side-view

  // main body
  ctx.fillStyle = '#4d5640';      // dark-olive green
  const yTop = -PACK_H / 1;
  ctx.fillRect(0, yTop, PACK_L, PACK_H);

  // horizontal dividers : â…“ & â…” down the height
  ctx.strokeStyle = '#222';
  ctx.lineWidth   = 0.3;
  for (let i = 1; i <= 2; i++) {
    const y = yTop + (i * PACK_H) / 3;
    ctx.beginPath();
      ctx.moveTo(0,     y);
      ctx.lineTo(PACK_L, y);
    ctx.stroke();
  }

ctx.restore();


  ctx.restore();
}





/* â”€â”€â”€ Patriot FU (not NASAMS) â€“ slanted track-launcher â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
 else if (s.type === 'fu') {
ctx.save();
  ctx.translate(s.x, s.y);

  /* â€” 50% scaled constants â€” */
  const TRUCK_L   =  8;      // was 16
  const TRUCK_H   =  2;      // was 4
  const CAB_L     =  2;      // was 4
  const SMALL_R   = 0.75;    // was 1.5
  const LAUNCH_L  = 6.5;     // was 13
  const LAUNCH_H  = 1.5;     // was 3
  const ARM_LEN   = 3.5;     // was 7
  const ELEVATE   = -45 * Math.PI / 180;

  /* â€” body â€” */
  ctx.fillStyle = '#2b2b2b';
  ctx.fillRect(-TRUCK_L/2, -TRUCK_H/2, TRUCK_L, TRUCK_H);

  /* â€” cab â€” */
  ctx.fillStyle = '#3a3a3a';
  ctx.beginPath();
    ctx.moveTo( TRUCK_L/2 - CAB_L, -TRUCK_H/2);
    ctx.lineTo( TRUCK_L/2,          -TRUCK_H/2);
    ctx.lineTo( TRUCK_L/2,           TRUCK_H/2);
    ctx.lineTo( TRUCK_L/2 - CAB_L,   TRUCK_H/2);
  ctx.closePath();
  ctx.fill();

  /* â€” wheels (two pairs) â€” */
  ctx.fillStyle = '#0a0a0a';
  const axleOff = TRUCK_L * 0.3;
  const pairGap = SMALL_R * 0.5 + 0.5;
  const wheelY  = TRUCK_H/2 + SMALL_R;
  const xs = [
    -axleOff - pairGap/2,
    -axleOff + pairGap/2,
     axleOff - pairGap/2,
     axleOff + pairGap/2
  ];
  xs.forEach(x => {
    ctx.beginPath();
    ctx.arc(x, wheelY, SMALL_R, 0, Math.PI*2);
    ctx.fill();
  });

  /* â€” launcher canister â€” */
  const pivotX = -TRUCK_L/2 + 1;  // half of previous +1px
  const pivotY = -TRUCK_H/2;
  ctx.save();
    ctx.translate(pivotX, pivotY);
    ctx.rotate(ELEVATE);

    ctx.fillStyle = '#4d5640';
    ctx.fillRect(0, -LAUNCH_H/2 - 1, LAUNCH_L, LAUNCH_H);

    /* centre-line: yMid = -1 px above pivot */
    ctx.strokeStyle = '#222';
    ctx.lineWidth   = 0.2;
    const yMid = -1;
    ctx.beginPath();
    ctx.moveTo(0, yMid);
    ctx.lineTo(LAUNCH_L, yMid);
    ctx.stroke();
  ctx.restore();

  /* â€” support arm â€” */
  ctx.strokeStyle = '#444';
  ctx.lineWidth   = 1.4;
  ctx.beginPath();
    ctx.moveTo(pivotX, pivotY);
    ctx.lineTo(
      pivotX + ARM_LEN * Math.cos(ELEVATE),
      pivotY + ARM_LEN * Math.sin(ELEVATE)
    );
  ctx.stroke();

  ctx.restore();
}
    
  /* â”€â”€â”€ CRC / C2 â€“ identical yellow bull-eye â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
 else if (s.type === 'crc') {
  ctx.save();
  const R_OUT = 6;
  const R_INNER = R_OUT / 2;

  ctx.fillStyle = '#ffd60a';
  ctx.beginPath();
  ctx.arc(s.x, s.y, R_OUT, 0, Math.PI * 2);
  ctx.fill();

  ctx.lineWidth   = 1;
  ctx.strokeStyle = 'white';
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(s.x, s.y, R_INNER, 0, Math.PI * 2);
  ctx.stroke();

  ctx.restore();

}
 /* â”€â”€â”€ ICC  (Bigfoot) â€“ red bull-eye + â€œT-barâ€ cross-hairs â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
 else if (s.type === 'icc') {
  ctx.save();
  ctx.translate(s.x, s.y);

  /* sizes (tweak to taste) */
  const R_OUT   = 6;          // radius of the red disk
  const R_INNER = R_OUT / 2;   // inner white ring
  const BAR_LEN = 6;           // cross-bar half-length (each â€œTâ€ top)
  const STEM    = 6;           // stem length outward from the bar
  const GAP     = 2;           // gap from disk edge â†’ start of bar

  /* 1 â€“ red disk */
  ctx.fillStyle = 'red';
  ctx.beginPath();
  ctx.arc(0, 0, R_OUT, 0, Math.PI * 2);
  ctx.fill();

  /* 2 â€“ white outer ring */
  ctx.lineWidth   = 1;
  ctx.strokeStyle = 'white';
  ctx.stroke();

  /* 3 â€“ inner white ring (Â½ radius) */
  ctx.beginPath();
  ctx.arc(0, 0, R_INNER, 0, Math.PI * 2);
  ctx.stroke();

 /* T-bars: pull them in tighter around the disk */
  const INSET = 3;                 // â†‘ move each T 3px closer to center
  const BAR   = BAR_LEN / 2;       // keep cap half-length
  const LIMB  = STEM;              // restore stem to original length
  const BASE  = R_OUT - INSET;     // new stem-start

ctx.lineWidth   = 1;
ctx.strokeStyle = 'lime';        // or your CSS var
ctx.beginPath();

/* Top */
ctx.moveTo(0, -BASE);
ctx.lineTo(0, -BASE - LIMB);
ctx.moveTo(-BAR, -BASE - LIMB);
ctx.lineTo( BAR, -BASE - LIMB);

/* Right */
ctx.moveTo(BASE, 0);
ctx.lineTo(BASE + LIMB, 0);
ctx.moveTo(BASE + LIMB, -BAR);
ctx.lineTo(BASE + LIMB,  BAR);

/* Bottom */
ctx.moveTo(0,  BASE);
ctx.lineTo(0,  BASE + LIMB);
ctx.moveTo(-BAR, BASE + LIMB);
ctx.lineTo( BAR, BASE + LIMB);

/* Left */
ctx.moveTo(-BASE, 0);
ctx.lineTo(-BASE - LIMB, 0);
ctx.moveTo(-BASE - LIMB, -BAR);
ctx.lineTo(-BASE - LIMB,  BAR);

ctx.stroke();


  ctx.restore();          // <-- add this brace to close the ICC block

 } 
 else {
      // default icon for other statics
      ctx.strokeStyle = colICC;
      ctx.beginPath();
      ctx.arc(s.x, s.y, 6, 0, 2 * Math.PI);
      ctx.stroke();
    }

    
    // â”€â”€â”€ CONDITIONAL STATIC LABELS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // only draw when tags are ON (tagMode > 0)
    if (tagMode > 0) {
      const lines = [ s.id ];

      // in ALL mode (tagMode===4) also show its status
      if (tagMode === 4) {
        let statusText;
        const now = Date.now();
        if (s.type === 'rad') {
          statusText = now < s.disabledUntil ? 'Disabled' : 'Active';
        } else if (s.type === 'fu' && s.id === 'NASAMS') {
          statusText = now < NASAMSDisabledUntil ? 'Reloading' : 'Ready';
        } else if (s.type === 'fu') {
          statusText = now < s.disabledUntilFu ? 'Reloading' : 'Ready';
        } else if (s.type === 'icc') {
          statusText = now < NASAMSDisabledUntil ? 'Weapons Red' : 'Ready';
        } else {
          statusText = 'Active';
        }
        lines.push(statusText);
      }

      // draw each line
      ctx.fillStyle    = colICC;
      ctx.textAlign    = 'left';
      ctx.textBaseline = 'middle';
      ctx.font         = '7px monospace';
      const xOff   = 8;    // px right of icon
      const yStep  = 12;   // px between lines

      lines.forEach((text, i) => {
        ctx.fillText(text, s.x + xOff, s.y + i * yStep);
      });
    }

  });

  
}

// â”€â”€â”€ DRAW TRACKS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawTracks(now) {
  // â”€â”€ EXPIRE STALE TAGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  tracks.forEach(o => {
    if (o.tag && now - o.tagTime > CFG.destroyMs) o.tag = null;
  });

  // â”€â”€ PREPARE COMMON COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const colHostile   = getComputedStyle(document.documentElement).getPropertyValue('--track');
  const colText      = getComputedStyle(document.documentElement).getPropertyValue('--text');
  const colTag       = getComputedStyle(document.documentElement).getPropertyValue('--braa');
  const colHighlight = getComputedStyle(document.documentElement).getPropertyValue('--yellow');

 // â”€â”€ SENSOR VISIBILITY FILTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const nasams = statics.find(s => s.id === 'NASAMS');
const tps75  = statics.find(s => s.type === 'c2Rad');
      /* TPS-75 has been red for >10 s?  */
  const blackout =
        tpsDownStart && Date.now() - tpsDownStart > 10_000;

tracks.forEach(o => {
  // vanish if destroyed or explicitly marked invisible
  if (o.destroyed || o._visible === false) return;

  


     // â”€â”€â”€ TBM ICON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (o.isTbm) {
    // â† your existing â€œ4â€‘bladeâ€ rotating TBM icon:
    for (let i = 0; i < 4; i++) {
      ctx.save();
      ctx.translate(o.x, o.y);
      ctx.rotate((i * 90 + now * 0.02) * Math.PI / 180);
      ctx.beginPath();
        ctx.moveTo(0, -6);
        ctx.lineTo(3, 0);
        ctx.lineTo(-3, 0);
      ctx.closePath();
      ctx.fillStyle = 'red';
      ctx.fill();
      ctx.restore();
    }

    // â”€â”€â”€ NEW: Velocity vector stick (twice as long) â”€â”€â”€â”€â”€â”€â”€â”€
    ctx.save();
      ctx.translate(o.x, o.y);
      ctx.rotate(d2r(o.heading));
      const maxLen = 60;  // â† was 20
      const len    = Math.min(1, o.speed / CFG.maxSpeedKts) * maxLen;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth   = 0.5;
      ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -len);
      ctx.stroke();
    ctx.restore();

    // â”€â”€â”€ NEW: Grey square around TBM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const size = 10;    // 20Ã—20px box
    ctx.strokeStyle = 'grey';
    ctx.lineWidth   = 1;
    ctx.strokeRect(o.x - size, o.y - size, size * 2, size * 2);

    return;  // skip the normalâ€track drawing
  }
    

    // 3b) normal hostile/friendly fill color
    ctx.fillStyle = o.friendly
      ? (o.alt > 100 ? 'green' : 'blue')
      : colHostile;

    // 3c) draw the little triangle
    ctx.save();
      ctx.translate(o.x, o.y);
      ctx.rotate(d2r(o.heading));
      ctx.beginPath();
        ctx.moveTo(0, -6);
        ctx.lineTo(4, 4);
        ctx.lineTo(-4, 4);
      ctx.closePath();
      ctx.fill();
    ctx.restore();
    // â”€â”€â”€ NEW: Velocity vector stick (twice as long) â”€â”€â”€â”€â”€â”€â”€â”€
    ctx.save();
    ctx.translate(o.x, o.y);
    ctx.rotate(d2r(o.heading));
    const maxLen = 30;  // â† doubled!
    const len    = Math.min(1, o.speed / CFG.maxSpeedKts) * maxLen;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth   = 0.4;
    ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -len);
    ctx.stroke();
  ctx.restore();

   // â€” new: friendly return logic â€”
if (o._visible && o.friendly) {
  // if TPSâ€‘75 is down, suspend like hostiles
  if (!tps75 || now >= (tps75.disabledUntil || 0)) {
    // start the 2â€¯s timer when it first becomes visible
    if (!o._friendlySince) o._friendlySince = now;
    // once past 2â€¯s, drop exactly one â€œ+ in a boxâ€
    if (!o._hasFriendlyReturned && now - o._friendlySince > 2000) {
      if (!tpsDownStart) {
      radarReturns.push({
        x:       o.x,
        y:       o.y,
        expires: now + 60_000,
        friendly: true          // tag it as friendly
      });
    }
      o._hasFriendlyReturned = true;
    }
  }
} else {
  // reset both hostile & friendly timers/flags
  o._visibleSince         = null;
  o._hasReturned          = false;
  o._friendlySince        = null;
  o._hasFriendlyReturned  = false;
} 
    // 3d) highlight selections
    if (o === selectedTrack) {
      ctx.strokeStyle = colText;
      ctx.lineWidth   = 2;
      ctx.beginPath();
      ctx.arc(o.x, o.y, 12, 0, Math.PI * 2);
      ctx.stroke();
    }
    if (o === selectedTrack2) {
      ctx.strokeStyle = colHighlight;
      ctx.lineWidth   = 2;
      ctx.strokeRect(o.x - 12, o.y - 12, 24, 24);
    }

    // 3e) draw tag text
    if (o.tag) {
      ctx.font         = '10px monospace';
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillStyle    = colTag;
      ctx.fillText(o.tag, o.x, o.y - 8);
    }
    // after your normal drawing in drawTracks(now), inside tracks.forEach(o => { â€¦ })

  if (o.friendly) {
      const iccStatic = statics.find(s => s.type === 'icc');
      const distToIcc = distNm(iccStatic, o);

      // when it first enters 30 NM, record the timestamp
      if (distToIcc <= 30 && o.identStart == null) {
        o.identStart = Date.now();
      }

      // blink IDENT only for 30 seconds from identStart
      if (o.identStart != null && Date.now() - o.identStart <= 30000) {
        // only blink while still within 30 NM
        if (distToIcc <= 30 && Math.floor(Date.now() / 500) % 2 === 0) {
          ctx.save();
            ctx.font         = '12px monospace';
            ctx.textAlign    = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle    = 'yellow';
            ctx.fillText('IDENT', o.x, o.y + 14);
          ctx.restore();
        }
      }
      // optional: clear identStart if it ever moves back out before 30s elapse:
      else if (distToIcc > 30) {
        o.identStart = null;
      }
    }
    /* â€”â€” blackout: outline every still-visible non-TBM track â€”â€” */
    if (blackout) {              // TBMs already handled above
      ctx.save();
      ctx.strokeStyle = '#888';  // same grey the TBM boxes use
      ctx.lineWidth   = 1;
      const s = 10;              // 20 Ã— 20 px like TBM
      ctx.strokeRect(o.x - s, o.y - s, s * 2, s * 2);
      ctx.restore();
    }

  });

// â”€â”€â”€ overlay TAGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (tagMode) {
       const now      = Date.now();
   // collect active Patriot radars
   const patriots = statics.filter(s =>
     s.type === 'rad' &&
     s.system === 'MPQâ€‘53' &&
     now >= s.disabledUntil &&
     s.animFrom == null
   );
   tracks.forEach(o => {

     if (!isTrackVisible(o)) return;   // single early-out does all the work

    const lines = [];

      // â‘  B/E range
      if ([1, 4].includes(tagMode)) {
  // 1) compute the â€œrawâ€ angle exactly as bearing() does internally
  const raw = (
    Math.atan2(o.x - bullseye.x, bullseye.y - o.y) * 180/Math.PI
    + 360
  ) % 360;

  // 2) always round *up* any fractional part
  const b = Math.ceil(raw);

  // 3) zeroâ€‘pad and push
  lines.push(
    `${('000' + b).slice(-3)}/${distNm(bullseye, o)}`
  );
}


      // â‘¡ JTN
      if ([2, 4].includes(tagMode)) lines.push(o.id);

      // â‘¢ INFO (hdg/alt/spd)
      if ([3, 4].includes(tagMode))
        lines.push(
          `${('000' + o.heading).slice(-3)}Â°/${o.speed} kts/${('000' + o.alt).slice(-3)} MSL`
        );

      // â‘£ ALTâ€‘ONLY (green)
      if (tagMode === 5) lines.push(('000' + o.alt).slice(-3));

      // â”€â”€ draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      ctx.font         = '10px monospace';
      ctx.textAlign    = 'left';
      ctx.textBaseline = 'middle';

      const colAlt = getComputedStyle(document.documentElement)
                     .getPropertyValue('--icc');   // same bright green

      lines.forEach((fu, i) => {
        ctx.fillStyle =
          tagMode === 1 && i === 0 ? colHighlight :         // yellow B/E
          tagMode === 5            ? colAlt        : colText; // green ALT
        ctx.fillText(fu, o.x + 8, o.y - 8 + i * 12);
      });
    });
  }
}
/* â”€â”€â”€ drawRadarReturns (only the colour lines changed) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function drawRadarReturns () {
  const graceOver =
    tpsDownStart && Date.now() - tpsDownStart > 10_000;     // >10 s?

  if (graceOver) return;            // TPS-75 still red â†’ show nothing

  const now = Date.now();
  radarReturns = radarReturns.filter(r => r.expires > now);

  ctx.lineWidth = 0.5;

  radarReturns.forEach(r => {
    /* FRIENDLY  â†’ green   |   Hostile â†’ grey  */
    ctx.strokeStyle = r.friendly ? 'lime' : '#888';

    /* draw the â€œ+â€ */
    ctx.beginPath();
      ctx.moveTo(r.x - 3, r.y);
      ctx.lineTo(r.x + 3, r.y);
      ctx.moveTo(r.x, r.y - 3);
      ctx.lineTo(r.x, r.y + 3);
    ctx.stroke();

    /* add the box if itâ€™s a friendly return */
    if (r.friendly) {
      ctx.beginPath();
        ctx.rect(r.x - 1, r.y - 1, 2, 2);
      ctx.stroke();
    }
  });

  ctx.restore();
}



// after your existing singleâ€‘selection highlight:
multiSelect.forEach(o => {
  ctx.strokeStyle = 'white';
  ctx.lineWidth   = 2;
  ctx.beginPath();
  ctx.arc(o.x, o.y, 14, 0, Math.PI*2);
  ctx.stroke();
});
const targets = multiSelect.length ? multiSelect : [selectedTrack];
targets.forEach(t => {
  // run your existing A/W/N/K logic here,
  // but replace references to `selectedTrack` with `t`
});
function renderMultiCards() {
  clearMultiCards();
  multiSelect.forEach((t,i) => {
    renderCard(t, 'track', 'left');
    const card = document.querySelectorAll('.card')[i];
    if (card) card.style.top = `${10 + i * 100}px`;
  });
}

function clearMultiCards() {
  document.querySelectorAll('.card').forEach(c => c.remove());
}


// â”€â”€â”€ DRAW THE SHIFT+DRAG â€œSELECTâ€ BOX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawSelectBox() {
  if (!multiDrag) return;
  // canvas px coords
  const x0 = multiDrag.x0, y0 = multiDrag.y0;
  const x1 = multiDrag.x1 ?? mouse.sx, y1 = multiDrag.y1 ?? mouse.sy;
  ctx.setTransform(1, 0, 0, 1, 0, 0);      // reset any pan/zoom
  ctx.strokeStyle = 'yellow';
  ctx.lineWidth   = 1;
  ctx.strokeRect(
    Math.min(x0, x1),
    Math.min(y0, y1),
    Math.abs(x1 - x0),
    Math.abs(y1 - y0)
  );
}

// â”€â”€â”€ DRAW THE DOUBLEâ€‘CLICK+HOLD â€œZOOMâ€ BOX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRubber() {
  if (!rubber) return;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth   = 1;
  const { cx, cy, ex, ey } = rubber;
  // rubber.cx/cy is center, ex/ey is current corner
  const ox = 2*cx - ex, oy = 2*cy - ey;
  ctx.strokeRect(
    Math.min(ex, ox),
    Math.min(ey, oy),
    Math.abs(ex - ox),
    Math.abs(ey - oy)
  );
}

   function drawDragLine () {
  if (!isDragging || !dragStart) return;

  ctx.strokeStyle =
    getComputedStyle(document.documentElement).getPropertyValue('--yellow');

  /* keep it ~1 CSS-pixel thick on the monitor */
  const px = 1 / scale;                 // undo the current zoom
  ctx.lineWidth = Math.max(0.5, px);    // clamp so it never vanishes

  ctx.beginPath();
  ctx.moveTo(dragStart.wx, dragStart.wy);
  ctx.lineTo(mouse.wx,      mouse.wy);
  ctx.stroke();
}

  

    function updateBombs(dt) {
  const now = Date.now();
  bombs = bombs.filter(b => b.expire > now);
  bombs.forEach(b => {
    // move toward its target
    const dx = b.target.x - b.x, dy = b.target.y - b.y;
    const d  = Math.hypot(dx, dy);
    if (d < 4) {
      // impact!
      if (b.target.system === 'TPSâ€‘75') {
        changeScore(-10, 'CREW, SL, TPSâ€‘75 was damaged. Loss of sensor coverage for 10â€¯min.');
        b.target.disabledUntil = now + 10 * 60 * 1000;
        tpsDownStart           = now;
         STATS.radarDowntime += 10 * 60;
 STATS.impacts.push('TPS-75');
      } else if (b.target.system === 'MPQâ€‘53') {
        const quad = getQuadrant({ x: b.target.x, y: b.target.y });
        changeScore(-7, `ADAFCO, ICC, ${quad} radar and one launcher damaged. Down for 10â€¯min.`);
        b.target.disabledUntil = now + 10 * 60 * 1000;
         STATS.radarDowntime += 10 * 60;
 STATS.impacts.push(`${getFuLabel(b.target)} Radar`);
      // â‹ NEW â€“ find the paired FU and remove ammo
  const fu = statics
    .filter(s => s.type === 'fu')
    .reduce((best, s) =>
      !best || distNm(s, b.target) < distNm(best, b.target) ? s : best,
    null);
  if (fu) damageLauncherAmmo(fu);

} else if (b.target.type === 'fu') {
  // bomb hit a launcher directly â†’ just drain ammo
  damageLauncherAmmo(b.target);
  STATS.impacts.push(`${getFuLabel(b.target)}`);

      }
      b.expire = 0; // remove
      return;
    }
    const ux = dx / d, uy = dy / d;
    b.x += ux * b.speedPxPerSec * dt;
    b.y += uy * b.speedPxPerSec * dt;
  });
}

function drawBombs() {
  bombs.forEach(b => {
    ctx.save();
      ctx.translate(b.x, b.y);
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(0, 0, 2, 0, Math.PI*2);  // radius = 2px
      ctx.fill();
    ctx.restore();
  });
}


    function drawMissiles() {
  missiles.forEach(m => {
    // compute angle towards its target
    const dx  = m.target.x - m.x;
    const dy  = m.target.y - m.y;
    const ang = Math.atan2(dy, dx);

    ctx.save();
      ctx.translate(m.x, m.y);
      ctx.rotate(ang);

      // draw a tiny blue â€œmissileâ€ shape
      ctx.fillStyle = '#3498db'; // nice blue
      ctx.beginPath();
        ctx.moveTo(-6, -2);      // tail left
        ctx.lineTo( 6,  0);      // nose right
        ctx.lineTo(-6,  2);      // tail bottom
      ctx.closePath();
      ctx.fill();
    ctx.restore();
  });
}



function updateMissiles(dt) {
  const now = Date.now();

  // first remove any that have lived â‰¥80â€¯s
  missiles = missiles.filter(m => m.expire > now);

missiles.forEach(m => {
  const dx = m.target.x - m.x;
  const dy = m.target.y - m.y;
  const d  = Math.hypot(dx, dy);

  if (d < 8) {
    // stop any pending intercept timer
    if (m.target.mslTimer) {
      clearTimeout(m.target.mslTimer);
      m.target.mslTimer = null;
    }
    // funnel the â€œhitâ€ through your geometry checker
    impactDecision(m.target);

    // expire this missile
    m.expire = 0;
    return;
  }

    const ux = dx / d, uy = dy / d;
    m.x += ux * m.speedPxPerSec * dt;
    m.y += uy * m.speedPxPerSec * dt;

  });
}


    // â”€â”€â”€ TRACKS UPDATE â”€â”€â”€ (overwrite existing updateTracks)
    function updateTracks(dt, now) {
      
  const pps = CFG.nmPerPixel/3600 * CFG.frameRate;
  const icc = statics.find(s => s.type === 'icc');

  // â‘  First, handle any autoâ€‘launches for armed waves
  tbmWaves.forEach(wave => {
    if (!wave.fireballArmed) return;
    wave.tbms.forEach(tbm => {
      if (tbm.destroyed) return;

      const d = distNm(icc, tbm);

      // 1) Patriot Launch Command at 50â€¯NM
      if (!tbm.patriotFired && d <= 50) {
        tbm.patriotFired = true;
        engageTbmWithPatriot(tbm);
      }
      // 2) NASAMS at 20â€¯NM (only if Patriot didnâ€™t catch it)
      else if (!tbm.NASAMSFired && d <= 20) {
        tbm.NASAMSFired = true;
        engageTbmWithNASAMS(tbm);
      }
    });
  });

  tracks.forEach(o => {
    if (o.destroyed) return;

    // â”€â”€â”€ CRUISE MISSILE IMPACT HANDLER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (o.isCruise) {
  // 1) assign a random static target once
  if (!o.cruiseTarget) {
    // filter out only the ICC so everything else can be hit
    const allTargets = statics.filter(s => s.type !== 'icc');
    o.cruiseTarget = allTargets[
      Math.floor(Math.random() * allTargets.length)
    ];
    /* --- give Quail a 30 % chance to hunt the Sentinel --- */
    if (!o.cruiseTarget) {
      const sentinel = statics.find(s => s.type === 'sentinel');
      if (sentinel && Math.random() < 0.30) {
        o.cruiseTarget = sentinel;
      } else {
        const pool = statics.filter(s => s.type !== 'icc' && s !== sentinel);
        o.cruiseTarget = pool[Math.floor(Math.random() * pool.length)];
      }
    }
  }

  // 2) steer straight at it
  o.heading = bearing(o, o.cruiseTarget);

  // 3) move normally (your existing movement code will apply it)

  // 4) when within 1â€¯NM â†’ impact
  const d = distNm(o, o.cruiseTarget);
  if (d <= 1) {
    const tgt = o.cruiseTarget;
    // radar damage (Patriot, TPS-75, **Sentinel**)
    if (tgt.system === 'MPQ-53' || tgt.system === 'TPS-75' || tgt.system === 'AN/MPQ-64') {
      /* points & message by radar type */
      const pts = tgt.system === 'TPS-75'      ? -10 : -7;
      const msg =
        tgt.system === 'TPS-75'
          ? 'CREW, SL, TPS-75 was damaged. Loss of sensor coverage for 10 min.'
          : tgt.system === 'AN/MPQ-64'
              ? 'Sentinel radar damaged â€“ 5 min outage.'
              : `ADAFCO, ICC, ${getQuadrant(tgt)} radar was damaged. Down for 10 min.`;
      changeScore(pts, msg);
      /* downtime: 10 min (TPS-75) vs 5 min (Sentinel) vs 10 min (Patriot) */
      const downMs =
        tgt.system === 'AN/MPQ-64' ? 5 * 60 * 1000 : 10 * 60 * 1000;
      tgt.disabledUntil = Date.now() + downMs;

      /* only TPS-75 sets the global blackout flag */
      if (tgt.system === 'TPS-75') tpsDownStart = now;

      STATS.radarDowntime += downMs / 1000;
      STATS.impacts.push(
        tgt.system === 'AN/MPQ-64' ? 'Sentinel radar' : 'TPS-75'
      );
    } else {
      // nonâ€‘radar static
      changeScore(-10, `Crew, SL, Quail Impact ${tgt.id}`);
    }
    /* ammo knock-down ---------------------------------------------- */
    if (tgt.type === 'fu') {
  damageLauncherAmmo(tgt);   // launcher or NASAMS takes the ammo loss
   STATS.impacts.push(`${getFuLabel(tgt)}`);
}
    // remove the cruise missile track
    o.destroyed = true;
    return;
  }
}
// â”€â”€â”€ end CRUISE block â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

   // â”€â”€â”€ Friendly descent: start at 200â€¯MSL, linearly descend 200â†’0 over 20â€¯NM â”€â”€â”€
    if (o.friendly) {
      const icc    = statics.find(s => s.type === 'icc');
      const dist   = distNm(icc, o);           // in NM
     if (dist > 20) {
       o.alt = 200;
      } else {
        // map dist [20â†’0] â†’ alt [200â†’0], then floor to nearest 10
        const rawAlt = (dist / 20) * 200;
        o.alt = Math.floor(rawAlt / 10) * 10;
        if (o.alt <= 0) {
          // landed
          o.destroyed = true;
          return;
        }
      }
      
    }

 
    // â”€â”€ TBM landing: hold at TBM altitude until within 30â€¯NM of BE, then descend smoothly â”€â”€
if (o.isTbm) {
  const distToBE = distNm(o, bullseye);
  if (distToBE > 30) {
    // hold high until inside 30â€¯NM
    o.alt = CFG.tbmAltitude;
  } else {
    // compute how many NM we moved this frame
    const distanceNm   = (o.speed * speedMultiplier) * (dt / 3600);
    const descentPerNm = 999 / 20;  
    o.alt = Math.max(o.destAlt, o.alt - descentPerNm * distanceNm);
    // when we hit ground, destroy
    if (o.alt <= o.destAlt) {
      o.destroyed = true;
      return;
    }
  }
  if (o.isTbm) {
         const nmDist = distNm(bullseye, o);
         if (!o.cratered && nmDist <= 1) {
        o.cratered = true;
        changeScore(-5, 'ADAFCO, TD, CRATER Runway -5');
        +STATS.assetsHit++;
        STATS.impacts.push('Runway Cratered');
        updateScoreDisplay();
        o.destroyed = true;
        return;    // skip any further perâ€‘track logic
      }
    }


}

// only forceâ€‘toâ€‘bullseye if they haven't dropped their bomb yet
if (
  mode === 'practice' &&
  !o.isEvading &&
  !o.bombLaunched5 &&
  !o.bombLaunched10 &&
  !o.isCruise
) {
  o.heading = bearing(o, bullseye);
}


    // Move at base speed Ã— level multiplier
    const vx = Math.sin(d2r(o.heading)) * o.speed * speedMultiplier * pps * dt;
    const vy = -Math.cos(d2r(o.heading)) * o.speed * speedMultiplier * pps * dt;
        // let tracks roam in unrestricted worldâ€‘space
    o.x += vx;
    o.y += vy;

    // â”€â”€â”€ hostiles drop bombs at 10â€¯NM and 5â€¯NM, then reverse â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (!o.friendly && !o.isTbm && !o.isCruise) {
  const dBE = distNm(bullseye, o);

  // â‘  first bomb at 10â€¯NM
  if (dBE <= 10 && !o.bombLaunched10) {
    o.bombLaunched10 = true;
    const brgRad   = d2r(bearing(bullseye, o));
    const ringPx   = 10 / CFG.nmPerPixel;
    const bombX    = bullseye.x + Math.sin(brgRad) * ringPx;
    const bombY    = bullseye.y - Math.cos(brgRad) * ringPx;
    const radars   = statics.filter(s => s.type === 'rad' || s.type === 'c2Rad');
    if (radars.length > 0) {
      const tgt = radars[Math.floor(Math.random() * radars.length)];
      bombs.push({
        x:             bombX,
        y:             bombY,
        target:        tgt,
        speedPxPerSec: (3000/3600) / CFG.nmPerPixel,
        expire:        Date.now() + 60_000
      });
    }
  }

  // â‘¡ second bomb at 5â€¯NM â†’ then reverse heading
  if (dBE <= 5 && !o.bombLaunched5) {
    o.bombLaunched5 = true;
    const brgRad   = d2r(bearing(bullseye, o));
    const ringPx   = 5 / CFG.nmPerPixel;
    const bombX    = bullseye.x + Math.sin(brgRad) * ringPx;
    const bombY    = bullseye.y - Math.cos(brgRad) * ringPx;
    const radars   = statics.filter(s => s.type === 'rad' || s.type === 'c2Rad');
    if (radars.length > 0) {
      const tgt = radars[Math.floor(Math.random() * radars.length)];
      bombs.push({
        x:             bombX,
        y:             bombY,
        target:        tgt,
        speedPxPerSec: (3000/3600) / CFG.nmPerPixel,
        expire:        Date.now() + 60_000
      });
    }
    // reverse course to run back out
    o.heading = (bearing(bullseye, o) + 180) % 360;
  }

  // â‘¢ vanish once both bombs are out and track reaches 190â€¯NM
  if (o.bombLaunched10 && o.bombLaunched5) {
    const distOut = distNm(bullseye, o);
    if (distOut >= 190) {
      o.destroyed = true;
      return;
    }
  }
}



  });
}

const oceanColor = '#00345c';
const darkColor  = getComputedStyle(document.documentElement)
                    .getPropertyValue('--bg');

// inside animate(now):
ctx.setTransform(1,0,0,1,0,0);
ctx.fillStyle = altMap ? oceanColor : darkColor;
ctx.fillRect(0, 0, canvas.width, canvas.height);

/// â”€â”€â”€ 10â€¯s visibility updater with 10â€¯s persistence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateVisibility(){
  const now       = Date.now();
  const nasams    = statics.find(s => s.id === 'NASAMS');
  const tps75     = statics.find(s => s.type === 'c2Rad');
  const activeRad = statics.filter(s =>
    (s.type === 'rad' || s.type === 'c2Rad' || s.type === 'sentinel') &&
    now >= (s.disabledUntil||0) &&
    s.animFrom == null
  );

  tracks.forEach(o => {
    const altLim = getDetectionRange(o.alt);
    let covered = false;

    // 1) Patriot wedge
    for (const r of activeRad) {
      const d = distNm(r, o);
      if (r.type === 'sentinel'      && distNm(r, o) <= 30                   ||  /* 30 NM bubble */
     r.type === 'rad'           && insideWedge(r, o) && d <= altLim      ||
          r.type === 'c2Rad' && d <= Math.min(190, altLim)) {
        covered = true;
        break;
      }
    }

    // 2) NASAMS ring
    if (!covered && nasams && distNm(nasams, o) <= 30) covered = true;

     // 3) TPS-75 fallback  **only if the TPS-75 is actually up**
    if (
      !covered &&
      tps75 &&
      now >= (tps75.disabledUntil || 0) &&          // <- honour downtime
      distNm(tps75, o) <= altLim
    ) covered = true;
 
     // â”€â”€ 10 s persistence after last good hit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         /* ---------------- persistence ---------------- */
    // first time we meet a brand-new track, _lastSeen is undefined.
    if (covered)            o._lastSeen = now;
    o._lastSeen ??= -1;                     // initialise once

    o._visible = covered || (now - o._lastSeen) <= 10_000;
 // â€”â€” NEW: radarâ€‘return â€œ+â€ generation â€”â€”
  // only for hostile air tracks (no friendlies/TBMs/cruise)
  if (o._visible && !o.isTbm) {
    // if TPSâ€‘75 is down, suspend
    if (!tps75 || now >= (tps75.disabledUntil || 0)) {
      // start the 2â€¯s timer when it first becomes visible
      if (!o._visibleSince) o._visibleSince = now;
      // once past 2â€¯s, drop exactly one marker
      if (!o._hasReturned && now - o._visibleSince > 2000) {
        if (!tpsDownStart) {
        radarReturns.push({
          x: o.x,
          y: o.y,
          expires: now + 60000
        });
      }
        o._hasReturned = true;
      }
    }
  } else {
    // reset if it goes invisible or isnâ€™t eligible
    o._visibleSince = null;
    o._hasReturned  = false;
  }
});
}
updateVisibility();          

// first pass before anyone draws
setInterval(updateVisibility,1000);

function createRadarReturnElement (r) {
  const { track, x, y, expires, friendly } = r;

  /* -------------------------------------------------- */
  /* 1)  FRIENDLIES get a permanent 4-digit octal code  */
  /* -------------------------------------------------- */
  if (friendly && !track.octalCode) {
    // one-time allocation in the 1000-7777 octal range
    const oct = Math.floor(Math.random() * (0o7777 - 0o1000 + 1) + 0o1000);
    track.octalCode = oct.toString(8).padStart(4, '0');
  }
  const octalLine = friendly
      ? `<div>${track.octalCode}</div>`   // â† always the same string
      : '';

  /* -------------------------------------------------- */
  /* 2)  build the DOM element exactly as before        */
  /* -------------------------------------------------- */
  const altFt  = track.alt * 100;
  const [br, rn] = formatBE(track).split('/');
  const beStr = `${br}Â° / ${rn} NM`;

  const el = document.createElement('div');
  el.className = 'radar-return';
  Object.assign(el.style, {
    left: `${x - 6}px`,
    top:  `${y - 6}px`,
    pointerEvents: 'auto'
  });
/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
     Hover â†’ fill the fixed sidebar
  â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
  el.addEventListener('pointerenter', (e) => {   /* pass the event */
    radarInfo.innerHTML = `
      <div>TPS-75</div>
      <div>${altFt.toLocaleString()} ft</div>
      ${octalLine}
      <div>${beStr}</div>`;
    radarInfo.style.display = 'block';
      moveInfo(e);                   // position it once
     el.addEventListener('pointermove', moveInfo);  /* same element */
 
  });
  el.addEventListener('pointerleave', () => radarInfo.style.display = 'none');

el.addEventListener('pointerdown', ev => ev.preventDefault());
  /* helper â€“ always keep the box 12Ã—12 px offset from the cursor */
function moveInfo(ev){
  const x = ev.clientX + 12;
  const y = ev.clientY - radarInfo.offsetHeight - 12;
  radarInfo.style.left = x + 'px';
  radarInfo.style.top  = y + 'px';
}

el.addEventListener('pointerleave', () => {
  radarInfo.style.display = 'none';
  el.removeEventListener('pointermove', moveInfo);
});
  returnLayer.appendChild(el);
  setTimeout(() => el.remove(), expires - Date.now());
}


// create a layer on top of the canvas for our â€œ+â€ markers
 const returnLayer = document.createElement('div');
 returnLayer.id = 'returnLayer';
 Object.assign(returnLayer.style, {
  position: 'absolute',
  /* shove it down by the headerâ€™s height */
  top:   `${document.querySelector('header').offsetHeight}px`,
 left:  0,
  width: '100%',
  height:'100%',
  pointerEvents: 'none'
 });
  document.body.appendChild(returnLayer);
// every 10 s, drop exactly one â€œ+â€ per visible radarâ€return
setInterval(() => {
  const now   = Date.now();
  const tps75 = statics.find(s => s.type === 'c2Rad');
  if (!tps75 || now < (tps75.disabledUntil || 0)) return;

  tracks.forEach(o => {
    if (!o._visible) return;
    const ret = {
      
      track:    o,
      x:        o.x,
      y:        o.y,
      expires:  now + 60_000,
      friendly: !!o.friendly
    };
    
    radarReturns.push(ret);
    createRadarReturnElement(ret);
  });
}, 10_000);
// on any pointer-down (mouse or touch), make the returns inert
window.addEventListener('pointerdown', () => {
  returnLayer.classList.add('inert');
}, { passive: true });

// on pointer-up, bring them back so hover/tooltips still work
window.addEventListener('pointerup', () => {
  returnLayer.classList.remove('inert');
}, { passive: true });

    let lastTime=performance.now();

/* 2) put this at the *very top* of your animate() (or main game-tick) */
(function trackTpsState () {
  const tps   = statics.find(s => s.type === 'c2Rad');      // the TPS-75
  const down  = tps && Date.now() < tps.disabledUntil;      // true = red

  if (down) {
    if (tpsDownStart === null) tpsDownStart = Date.now();   // first frame
  } else {
    tpsDownStart = null;                                    // back online
  }
})();

  // â”€â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function animate(now) {
  // â”€â”€â”€ 1) compute delta â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   let dt = (now - lastTime) / 1000;
  lastTime = now;

    if (paused)           dt = 0;                 // freeze when paused
    else if (fastForward) dt *= fastFactor;       // scale by 2 Ã— or 4 Ã—
  // â”€â”€â”€ 2) update track positions, spawns, etc. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateTracks(dt, now);

  // â”€â”€â”€ 3) process any AFFIRMed tracks waiting to ENGAGE â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (mode === 'practice') {      // â† run this block ONLY in Air-Battle
  const icc = statics.find(s => s.type === 'icc');
  pendingEngagements = pendingEngagements.filter(trk => {
    // drop if destroyed or reâ€‘tagged
    if (trk.destroyed || trk.tag !== 'AFFIRM') return false;

    // assign a perâ€‘track random engage distance if not set
    if (trk.engageThreshold == null) {
      trk.engageThreshold = 55 + Math.random() * 20; // random [50,70) NM
    }

    // check distance from ICC
    const d = distNm(icc, trk);
    if (d <= trk.engageThreshold) {
  phase = 'engage';
  // tag the main track + any within 5â€¯NM
  const engaged   = engageCluster(trk);
const ids       = engaged.map(t => t.id).join(', ');
const quadrant  = getQuadrant(trk);
const beString  = formatBE(trk);

// single vs. cluster message
if (engaged.length > 1) {
  statusEl.textContent =
    `ADAFCO, SL, ENGAGE ${quadrant}, ` +
    `Tracks ${ids}, ` +
    `Group B/E ${beString}, Hostile`;
} else {
  statusEl.textContent =
    `ADAFCO, SL, ENGAGE ${quadrant}, ` +
    `Track ${ids}, ` +
    `B/E ${beString}, Hostile`;
}

nextQueueTrack();  // or whatever follows

  return false;
}


    return true;     // keep waiting
  });
  // 3b) Now autoâ€‘ENGAGE any other unâ€‘engaged hostiles at 40â€¯NM
  tracks.forEach(trk => {
    if (
      trk.destroyed ||
      trk.friendly ||
      trk.tag === 'AWAY' ||
      trk.tag === 'ENGAGE' ||
      trk.everEngaged
    ) return;

    const d = distNm(icc, trk);
    if (d <= 40) {
  phase = 'engage';
  // tag the main track + neighbors
  const engaged   = engageCluster(trk);
const ids       = engaged.map(t => t.id).join(', ');
const quadrant  = getQuadrant(trk);
const beString  = formatBE(trk);

// single vs. cluster message
if (engaged.length > 1) {
  statusEl.textContent =
    `ADAFCO, SL, ENGAGE ${quadrant}, ` +
    `Tracks ${ids}, ` +
    `Group B/E ${beString}, Hostile`;
} else {
  statusEl.textContent =
    `ADAFCO, SL, ENGAGE ${quadrant}, ` +
    `Track ${ids}, ` +
    `B/E ${beString}, Hostile`;
}

nextQueueTrack(); 
}

  });
}


  updateMissiles(dt);
  updateBombs(dt);



// â”€â”€â”€ A) clear & fill â€œseaâ€ background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ctx.setTransform(1, 0, 0, 1, 0, 0);
ctx.fillStyle = altMap
  ? oceanColor   // StyleÂ 2: deep ocean
  : darkColor;   // StyleÂ 1: original dark
ctx.fillRect(0, 0, canvas.width, canvas.height);



  // â”€â”€â”€ B) draw screenâ€space vignette UNDER everything else â”€â”€â”€â”€
  //    (will never move or scale with world)
  const cx = canvas.width  / 2;
  const cy = canvas.height / 2;
  // inner radius = roughly island radius in screen px (tweak as needed)
  const inner = Math.min(canvas.width, canvas.height) * 0.2;
  // outer radius = diagonal to cover full screen corners
  const outer = Math.hypot(canvas.width, canvas.height) / 2;
  const vg = ctx.createRadialGradient(cx, cy, inner, cx, cy, outer);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(1, 'rgba(10,10,13,1)');  // same as var(--bg)
  ctx.fillStyle = vg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);


// â”€â”€â”€ SHIFT+ hover overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (shiftDown) {
  // 1) yellow 3â€¯NM circle at cursor (screen coords)
  ctx.setTransform(1,0,0,1,0,0);
  const rScreen = nmToPx(3) * scale;
  ctx.strokeStyle = 'yellow';
  ctx.lineWidth   = 1;
  ctx.beginPath();
    ctx.arc(mouse.sx, mouse.sy, rScreen, 0, Math.PI*2);
  ctx.stroke();


const hovered = tracks.filter(t => {
 if (!isTrackVisible(t)) return false;
  return distNm({ x: mouse.wx, y: mouse.wy }, t) <= 3;  // â‰¤â€¯3 NM bubble
});

  if (hovered.length) {
    // 3) draw small card bottomâ€‘left
    const cardW = 60, cardH = 140, pad = 8;
    const x0 = 10, y0 = canvas.height - cardH - 10;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(x0, y0, cardW, cardH);
    ctx.strokeStyle = 'yellow';
    ctx.lineWidth   = 1;
    ctx.strokeRect(x0, y0, cardW, cardH);

    // 4) altitude axis
    const axisX      = x0 + cardW/2,
          axisTop    = y0 + pad,
          axisBottom = y0 + cardH - pad;
          ctx.beginPath();
        ctx.moveTo(axisX, axisTop);
        ctx.lineTo(axisX, axisBottom);
        ctx.stroke();

        // 4a) ticks every 10â€¯kâ€¯ft (every 100 alt units)
        for (let a = 100; a < 600; a += 100) {
          const pct   = a / 600;
          const yTick = axisTop + (1 - pct) * (axisBottom - axisTop);
          ctx.beginPath();
            ctx.moveTo(axisX - 4, yTick);
            ctx.lineTo(axisX + 4, yTick);
          ctx.stroke();
        }

    // labels
    ctx.fillStyle    = 'white';
    ctx.font         = '8px monospace';
    ctx.textAlign    = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('600', axisX, axisTop - 6);
    ctx.fillText('0',   axisX, axisBottom + 6);

    // 5) dots
    hovered.forEach(o => {
      const pct  = Math.max(0, Math.min(1, o.alt / 600));
      const yPos = axisTop + (1 - pct) * (axisBottom - axisTop);
      const col  = o.friendly
                 ? (o.alt > 100 ? 'green' : 'blue')
                 : getComputedStyle(document.documentElement).getPropertyValue('--track');
      ctx.fillStyle = col;
      ctx.beginPath();
        ctx.arc(axisX, yPos, 4, 0, Math.PI*2);
      ctx.fill();
    });
  }
}

// â”€â”€â”€ C) now switch into world coords (pan & zoom) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ctx.setTransform(
  scale, 0,
  0, scale,
  -offX * scale,
  -offY * scale
  
);
const ui = document.getElementById('uiLayer');
ui.style.transform = 
  `matrix(${scale}, 0, 0, ${scale}, ${-offX * scale}, ${-offY * scale})`;

syncReturnLayer();   // <-- add this


  // â”€â”€â”€ D) draw island, statics, tracks, etc. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (bgImg.complete) {
  // â‘  compute aspect ratio
  const ratio = bgImg.width / bgImg.height;

  // â‘¡ decide on one â€œworld-spaceâ€ sizeâ€”e.g. Â¼ of the worldâ€™s height
  const imgH  = worldHeight / 2.7 * 3;    // â† zoom in 30%
  const imgW = imgH * ratio;   // keeps w/h = original


  // â”€â”€â”€ DRAW THE ISLAND, CENTERED ON ICC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (bgImg.complete) {
  const ratio = bgImg.width / bgImg.height;

  // 1) choose realâ€‘world diameter in NM (e.g. twice your max spawn radius)
  const diameterNm = CFG.maxSpawnNm * 2;

  // 2) convert that to worldâ€‘px (independent of viewport size)
  const diameterPx = diameterNm / CFG.nmPerPixel;

  // 3) preserve aspect ratio
  const imgW = diameterPx;
  const imgH = diameterPx / ratio;

  // 4) where in the *source* image is your ICC/hillâ€‘top?
  //    â†’ measure once in Photoshop (or your imageâ€‘viewer).
  //    Say the ICC is at pixel (iccPxX, iccPxY) in the original bgImg.
  const iccPxX =670;  // â† replace with your measured X
  const iccPxY = 500;  // â† replace with your measured Y

  // 5) convert that to [0â€¦1] anchor ratios
  const anchorX = iccPxX / bgImg.width;
  const anchorY = iccPxY / bgImg.height;

  // 6) compute draw position so that that imageâ€‘pixel lands on bullseye
  const drawX = bullseye.x - imgW * anchorX;
  const drawY = bullseye.y - imgH * anchorY;

  // finally, draw
  ctx.drawImage(
    bgImg,
    0, 0, bgImg.width, bgImg.height,
    drawX, drawY,
    imgW, imgH
  );
}

}


  drawStatics();
  drawCompass();
  drawTracks(now);
    // â†â”€â”€ ADD YOUR MULTIâ€‘SELECT HIGHLIGHT HERE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    multiSelect.forEach(o => {
    ctx.strokeStyle = 'white';
    ctx.lineWidth   = 2;
    ctx.beginPath();
    ctx.arc(o.x, o.y, 14, 0, Math.PI*2);
    ctx.stroke();
  });
  drawRadarReturns();    // â† draw the â€œ+â€ markers here
  drawMissiles(); 
  drawBombs();  
  drawDragLine();
  drawRubber();
  drawSelectBox();  

  requestAnimationFrame(animate);
}
// one-frame tick used by the â€œStepâ€ button
function gameStep() {
  const fakeNow = performance.now();
  animate(fakeNow);
}
requestAnimationFrame(animate);


    // â”€â”€â”€ INPUT HANDLING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function storeMouse(ev) {
  const rect = canvas.getBoundingClientRect();

  /* always work in viewport (client) pixels */
  let cx, cy;
  if (ev.clientX != null) {                // Pointer / Mouse
    cx = ev.clientX;
    cy = ev.clientY;
  } else if (ev.touches && ev.touches.length) { // Touch
    cx = ev.touches[0].clientX;
    cy = ev.touches[0].clientY;
  } else {
    return;                                // unexpected event object
  }

  mouse.sx = cx - rect.left;
  mouse.sy = cy - rect.top;
  mouse.px = cx;
  mouse.py = cy;

  const w = scrToWorld(mouse.sx, mouse.sy);
  mouse.wx = w.x;
  mouse.wy = w.y;
  updateCursorLabel();
}

    //let lastTap = null;                                   // â¬…ï¸ remembers last canvas tap
    canvas.addEventListener('touchstart', e=>{
      if(e.touches.length===2){
        pinch.active=true;
        pinch.startDist=distTouch(e.touches[0],e.touches[1]);
        pinch.startScale=scale;
        const rect=canvas.getBoundingClientRect();
        const cx=(e.touches[0].clientX-rect.left+e.touches[1].clientX-rect.left)/2;
        const cy=(e.touches[0].clientY-rect.top +e.touches[1].clientY-rect.top)/2;
        pinch.center=scrToWorld(cx,cy);
      }
    },{passive:false});

    canvas.addEventListener('touchmove', e=>{
      if(pinch.active&&e.touches.length===2){
        e.preventDefault();
        const newDist=distTouch(e.touches[0],e.touches[1]);
        const f=newDist/pinch.startDist;
        scale=pinch.startScale*f;
        const rect=canvas.getBoundingClientRect();
        const cx=(e.touches[0].clientX-rect.left+e.touches[1].clientX-rect.left)/2;
        const cy=(e.touches[0].clientY-rect.top+e.touches[1].clientY-rect.top)/2;
        offX=pinch.center.x-cx/scale;
        offY=pinch.center.y-cy/scale;
        syncReturnLayer();           // keep markers aligned
      } else if(e.touches.length===1){
        storeMouse(e);
        if(rubber){ rubber.ex=mouse.sx; rubber.ey=mouse.sy; }
      }
    },{passive:false});

    canvas.addEventListener('touchend', e=>{
      if(pinch.active && e.touches.length<2) pinch.active=false;
    },{passive:false});

    canvas.addEventListener('mousemove', e=>{
      storeMouse(e);
      if(rubber){ rubber.ex=mouse.sx; rubber.ey=mouse.sy; }
    });

    canvas.addEventListener('mousedown', e=>{
      if(e.button!==0) return;
      storeMouse(e);
      if(e.detail===2){
        rubber={cx:mouse.sx,cy:mouse.sy,ex:mouse.sx,ey:mouse.sy};
      } else {
        isDragging=true; dragStart={...mouse};
      }
    });

    window.addEventListener('mouseup', e=>{
      if(e.button!==0) return;
      storeMouse(e);
      isDragging=false; dragStart=null;
      if(!rubber) return;
      const dx=Math.abs(mouse.sx-rubber.cx)*2,
            dy=Math.abs(mouse.sy-rubber.cy)*2;
      if(dx>10&&dy>10){
        // new: center the selected worldâ€region in the middle of the screen
const w0 = scrToWorld(rubber.cx - dx/2, rubber.cy - dy/2),
      w1 = scrToWorld(rubber.cx + dx/2, rubber.cy + dy/2);
const newScale = Math.min(
  worldWidth  / (w1.x - w0.x),
  worldHeight / (w1.y - w0.y)
);
scale = newScale;

// compute the worldâ€coordinates of the regionâ€™s center
const worldCenterX = (w0.x + w1.x) / 2;
const worldCenterY = (w0.y + w1.y) / 2;

// offset so that this worldâ€center maps to screen center
offX = worldCenterX - (worldWidth  / 2) / scale;
offY = worldCenterY - (worldHeight / 2) / scale;
syncReturnLayer();           // keep markers aligned

      }
      rubber=null;
    });

    canvas.addEventListener('wheel', e=>{
      e.preventDefault(); storeMouse(e);
      const f=e.deltaY<0?1.1:1/1.1;
      const cx=e.clientX-canvas.getBoundingClientRect().left,
            cy=e.clientY-canvas.getBoundingClientRect().top;
      const world=scrToWorld(cx,cy);
      scale*=f;
      offX=world.x-cx/scale;
      offY=world.y-cy/scale;
      syncReturnLayer();           // keep markers aligned
    },{passive:false});

    function updateCursorLabel(){
      const world={x:mouse.wx,y:mouse.wy};
      const b=('000'+bearing(bullseye,world)).slice(-3),
            r=distNm(bullseye,world);
      let html=`<span class="be">${b}/${r}</span>`;
      if(isDragging&&dragStart){
        const start={x:dragStart.wx,y:dragStart.wy},
              b2=('000'+bearing(start,world)).slice(-3),
              r2=distNm(start,world);
        html=`<span class="braa">${b2}/${r2}</span><br>`+html;
      }
      label.innerHTML=html;
      label.style.left = `${mouse.px + 10}px`;
label.style.top  = `${mouse.py + 5}px`;

    }
    
    /**
 * Generic card renderer for tracks or statics, on either side.
 * @param {object} obj    â€“ the track or static object
 * @param {'track'|'static'} type
 * @param {'left'|'right'} side
 */
function renderCard(obj, type, side) {
  // remove any old
  document.querySelectorAll(`.card${side==='right'?'2':''}`).forEach(c => c.remove());

  // container
  const d = document.createElement('div');
  d.className = side==='right' ? 'card card2' : 'card';
  if (side==='right') {
    Object.assign(d.style, {
      position: 'fixed',
      top:      '10px',
      right:    '10px',
      left:     'auto',
      zIndex:   '15'
    });

  } else {
    // leftâ€‘click cards already styled via .card CSS
  }

  // build content
  let html = '';
  if (type === 'track') {
    html += `
      <h3>${side==='right'?'2ï¸âƒ£ ':''}Track ${obj.id}</h3>
      <div>
        ${('000'+obj.heading).slice(-3)}Â° /
        ${obj.speed} kts /
        <span style="color:var(--icc)">${('000'+obj.alt).slice(-3)}</span>
      </div>
      <div>ID: ${obj.friendly?'Friendly':'Hostile'}</div>
    `;
    if (obj.isCruise) {
  html += `<div style="font-size:0.9rem; color: var(--yellow);">
             Cruise Missile
           </div>`;
}
} else { 
  // static
  const now = Date.now();

  // Patriot launchers
      if (obj.type === 'fu' && obj.id !== 'NASAMS') {
        html += `
          <h3>${side==='right'?'2ï¸âƒ£ ':''}FU ${obj.id}</h3>
          <div>Status: ${ now < obj.disabledUntilFu ? 'Reloading' : 'Ready' }</div>
          <hr>
          <h4>Magazine Status</h4>
          <ul style="text-align:left; font-size:0.9rem; margin:0; padding-left:1.2em;">
            <li>PACâ€‘2: ${obj.ammo.pac2}</li>
            <li>PACâ€‘3: ${obj.ammo.pac3}</li>
            <li>MSE:  ${obj.ammo.mse}</li>
            <li>Engagements Left: ${obj.engagementsRemaining}</li>
          </ul>
        `;
      }
      // NASAMS specialâ€‘case
      else if (obj.type === 'fu' && obj.id === 'NASAMS') {
        html += `
          <h3>NASAMS</h3>
     <div>Status: ${ Date.now() < NASAMSDisabledUntil ? 'Reloading' : 'Ready' }</div>
      <hr>
     <h4>AIMâ€‘120 Missiles</h4>
      <ul style="text-align:left; padding-left:1.2em;">
        <li>AIMâ€‘120: ${NASAMSMissiles}</li>
        <li>Engagements Left: ${Math.floor(NASAMSMissiles/2)}</li>
      </ul>
        `;
    } else {
// Distinguish MPQ-53, TPS-75, Sentinel vs. everything else
    const now = Date.now();
    if (obj.type === 'rad' || obj.type === 'c2Rad' || obj.type === 'sentinel') {
      // pick the human-readable name
      const name =
        obj.type === 'c2Rad'             ? 'TPS-75'        :
        obj.type === 'rad'               ? 'Patriot MPQ-53':
        /* obj.type === 'sentinel' */       `Sentinel ${obj.system}`;
      const isUp = now >= (obj.disabledUntil || 0);
      html += `
        <h3>${name} Radar</h3>
        <div>JTN:   ${obj.id}</div>
        <div>ID:    ${obj.label || 'â€”'}</div>
        <div>Status:${isUp ? ' Active' : ' Inactive'}</div>
      `;
  } else {
      // ICC & CRC get a â€œJTN + ID: FRIENDâ€ card
      if (obj.type === 'icc' || obj.type === 'crc') {
        const name = obj.type === 'icc' ? 'ICC' : 'CRC';
        html += `
          <h3>${name}</h3>
          <div>JTN:   ${obj.id}</div>
          <div>ID:    ${obj.label || 'FRIEND'}</div>
          <div>Status: Active</div>
        `;
      }
      // everyone else falls back to the generic titleMap
      else {
        const titleMap = {
          fu:  'Patriot Launcher',
          icc: 'ICC',
          C2:  'C2',
          crc: 'CRC',
        };
        const title = titleMap[obj.type] || obj.type.toUpperCase();
        html += `
          <h3>${title}</h3>
          <div>ID: ${obj.id}</div>
          <div>Status: Active</div>
        `;
      }
    }
    }}

html += `<button class="close-btn">Ã—</button>`;
  d.innerHTML = html;
  d.querySelector('button').onclick = () => d.remove();
  document.body.appendChild(d);
}

// rewrite the three old functions to just call renderCard:
function showCard(t)         { renderCard(t, 'track',  'left'); }
function showStaticCard(s)   { renderCard(s, 'static', 'left'); }
function showCard2(obj,type) { renderCard(obj,type,    'right'); }



function pickObject() {
  // translate that 12â€¯px into worldâ€‘space by dividing by your current scale:
  const HIT_R = dynamicClickRadius() / scale;

  const Y_OFF = 6;  // unchanged

  selectedTrack = tracks.find(t => {
    const dx = mouse.wx - t.x;
    const dy = mouse.wy - (t.y - Y_OFF);
    return Math.hypot(dx, dy) < HIT_R;
  }) || null;

  if (selectedTrack) {
    selectedStatic = null;
    showCard(selectedTrack);
    return;
  }

  // Try selecting a static under the mouse
  selectedStatic = statics.find(s => {
    const dx = s.x - mouse.wx,
          dy = s.y - mouse.wy;
    return Math.hypot(dx, dy) < 12;
  }) || null;

  if (selectedStatic) {
    selectedTrack = null;
    showStaticCard(selectedStatic);
    return;
  }

  // Clicked empty space â†’ clear left selection only
  selectedTrack  = null;
  selectedStatic = null;
  document.querySelectorAll('.card').forEach(c => c.remove());
}



    // â”€â”€â”€ UNIFIED TAP/CLICK via PointerEvents â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    canvas.addEventListener('pointerup', e => {
          const primary = (e.button === 0 || e.button === -1);   // -1 = touch
          if (!primary || e.target !== canvas) return;
    // *before* you call pickObject(), bail if we just did a drag:
    if (multiDrag) {
    // weâ€™ll clear multiDrag & show cards in the mouseup that handles the box
    return;
  }
  e.preventDefault();
   mouse.sx = e.offsetX; mouse.sy = e.offsetY;
   mouse.px = e.clientX; mouse.py = e.clientY;
   const w = scrToWorld(mouse.sx, mouse.sy);
   mouse.wx = w.x; mouse.wy = w.y;
   updateCursorLabel();
   lastTap = { wx: mouse.wx, wy: mouse.wy }; 
   // â”€â”€â”€ Handle pending Oâ€‘reorientation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   if (pendingReorient && pendingStatic) {
        const s     = pendingStatic;
        const newDir = bearing(s, { x: mouse.wx, y: mouse.wy });
        const now   = Date.now();

        // animate wedge from oldâ†’new, disable 90s
        s.animFrom      = s.wedgeDir;
        s.animTo        = newDir;
        s.animStart     = now;
        s.disabledUntil = now + 90 * 1000;

        feedbackEl.textContent = `Reorienting Launcher ${s.id} to ${newDir}Â°, weapons red for 90 seconds`;

        // clear the â€œarmedâ€ state
        pendingReorient = false;
        pendingStatic   = null;
        return;
      } 
     
   pickObject();
 });

    // â”€â”€â”€ DESKTOP CLICK fallback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    canvas.addEventListener('click', e => {
          const primary = (e.button === 0 || e.button === -1);   // -1 = touch
          if (!primary || e.target !== canvas) return;
  e.preventDefault();
   mouse.sx = e.offsetX; mouse.sy = e.offsetY;
   mouse.px = e.clientX; mouse.py = e.clientY;
   const w = scrToWorld(mouse.sx, mouse.sy);
   mouse.wx = w.x; mouse.wy = w.y;
   updateCursorLabel();
   lastTap = { wx: mouse.wx, wy: mouse.wy };   
   pickObject();
 });
// â”€â”€â”€ 4) Right-click handler on the canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();

  // update mouse coords like left-click
  mouse.sx = e.offsetX;
  mouse.sy = e.offsetY;
  mouse.px = e.clientX;
  mouse.py = e.clientY;
  const w = scrToWorld(mouse.sx, mouse.sy);
  mouse.wx = w.x; 
  mouse.wy = w.y;
  updateCursorLabel();

  // convert screenâ€‘px into worldâ€‘px at current zoom:
  const HIT_R_SCR = dynamicClickRadius();
selectedTrack = tracks.find(t => {
  /* project track to current screen coords */
  const sx = (t.x - offX) * scale;
  const sy = (t.y - offY) * scale - 6 * scale;   // keep the same visual offset
syncReturnLayer();           // keep markers aligned
  return Math.hypot(mouse.sx - sx, mouse.sy - sy) < HIT_R_SCR;
}) || null;

  if (selectedTrack2) {
    selectedStatic2 = null;
    showCard2(selectedTrack2, 'track');
    return;
  }

  // Try picking a static for right selection
  selectedStatic2 = statics.find(s => {
    const dx = s.x - mouse.wx;
    const dy = s.y - mouse.wy;
    return Math.hypot(dx, dy) < 12;  // statics still use a fixed 12â€¯px worldâ€‘space radius
  }) || null;

  if (selectedStatic2) {
    selectedTrack2 = null;
    showCard2(selectedStatic2, 'static');
    return;
  }

  // Right-clicked empty space â†’ clear right selection only
  selectedTrack2  = null;
  selectedStatic2 = null;
  document.querySelectorAll('.card2').forEach(c => c.remove());
});


    // â”€â”€â”€ GLOBAL KEY HANDLER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.addEventListener('keydown', e => {
  const k = e.key;

  // â”€â”€â”€ PAN WITH ARROWS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(k)) {
    e.preventDefault();
    const delta = 10 / CFG.nmPerPixel;
    switch (k) {
      case 'ArrowUp':    offY -= delta; break;
      case 'ArrowDown':  offY += delta; break;
      case 'ArrowLeft':  offX -= delta; break;
      case 'ArrowRight': offX += delta; break;
      syncReturnLayer();           // keep markers aligned
    }
    return;
  }

  // â”€â”€â”€ ZOOM WITH + / - â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (k === '+' || k === '-') {
    e.preventDefault();
    const f = k === '+' ? 1.1 : 1/1.1;
    const cx = mouse.sx, cy = mouse.sy;
    const world = scrToWorld(cx, cy);
    scale *= f;
    offX = world.x - cx / scale;
    offY = world.y - cy / scale;
    syncReturnLayer();           // keep markers aligned
    return;
  }

  // â”€â”€â”€ LOWERCASE FOR REST OF HOTKEYS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const key = k.toLowerCase();

  // â”€â”€â”€ MULTIâ€‘SELECT A/N/W/K HANDLER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (mode === 'practice' && multiSelect.length && ['a','n','w','k','h'].includes(key)) {
    e.preventDefault();
    multiSelect.forEach(t => {
      // NEGATE
      if (key === 'n') {
        clearTimeout(coverTimer);
        t.tag     = 'NEGATE';
        t.tagTime = Date.now();
        negatedStack.push(t);
      }
      // AFFIRM
      else if (key === 'a') {
        clearTimeout(coverTimer);
        t.tag     = 'AFFIRM';
        t.tagTime = Date.now();
        phase     = 'affirm';
        statusEl.textContent =
          `SL, ADAFCO, BIRDS AFFIRM Track ${t.id}, B/E ${('000'+bearing(bullseye,t)).slice(-3)}/${distNm(bullseye,t)}`;
        if (!pendingEngagements.includes(t)) pendingEngagements.push(t);
        coverTimer = setTimeout(nextQueueTrack, 5000);
      }
      
      
// â”€â”€â”€ HOLD FIRE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
else if (key === 'h') {
  if (multiSelect.length) {
    // group HOLD FIRE
    const ids = multiSelect.map(o => o.id).join(', ');
    statusEl.textContent =
      `ICC, ADAFCO, HOLD FIRE Tracks ${ids}`;
    multiSelect.forEach(o => {
      const pendingTimer = o.mslTimer;
      setTimeout(() => {
        // cancel intercept if still pending
        if (pendingTimer) {
          clearTimeout(pendingTimer);
          o.mslTimer = null;
        }
        // selfâ€‘destruct any inbound missiles
        missiles = missiles.filter(m => m.target !== o);
      }, 5000);
    });
  } else {
    // singleâ€‘track HOLD FIRE
    const b    = ('000' + bearing(bullseye, t)).slice(-3);
    const r    = distNm(bullseye, t);
    const quad = getQuadrant(t);
    statusEl.textContent =
      `ICC, ADAFCO, HOLD FIRE Track ${t.id} Group B/E ${b}/${r}, ${quad}`;
    const pendingTimer = t.mslTimer;
    setTimeout(() => {
      // cancel intercept if still pending
      if (pendingTimer) {
        clearTimeout(pendingTimer);
        t.mslTimer = null;
      }
      // selfâ€‘destruct any inbound missiles
      missiles = missiles.filter(m => m.target !== t);
    }, 5000);
  }
}

  });

    // keep the cards up (or call clearMultiCards() if you prefer)
    return;
  }
window.addEventListener('keydown', e => {
  if (e.key.toLowerCase() === 'w' && multiSelect.length) {
    e.preventDefault();
    multiSelect.forEach(t => {
      t.tag     = 'AWAY';
      t.tagTime = Date.now();
      // launch(t);
    });
  }
});

// â”€â”€â”€ HOLDâ€‘FIRE HOTKEY (H) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (key === 'h') {
  e.preventDefault();
  if (selectedTrack) {
    const t    = selectedTrack;
    const b    = ('000' + bearing(bullseye, t)).slice(-3);
    const r    = distNm(bullseye, t);
    const quad = getQuadrant(t);

    // 1) Show HOLD FIRE message immediately
    statusEl.textContent =
      `ICC, ADAFCO, HOLD FIRE Track ${t.id} Group B/E ${b}/${r}, ${quad}`;

    // 2) Grab and defer the intercept timer cancellation
    const pendingTimer = t.mslTimer;

    // 3) Find all missiles currently inbound on that track
    const inbound = missiles.filter(m => m.target === t);

    // 4) After 5â€¯s, cancel the intercept and selfâ€‘destruct missiles
    setTimeout(() => {
      // cancel scheduled impactDecision if still pending
      if (pendingTimer) {
        clearTimeout(pendingTimer);
        t.mslTimer = null;
      }
      // remove all those inbound missiles
      missiles = missiles.filter(m => m.target !== t);
    }, 5000);
  }
}


  // â”€â”€â”€ â€˜Oâ€™ arms the next tap to reorient the selected radar â”€â”€â”€
  if (k === 'o' && selectedStatic && selectedStatic.type === 'rad') {
    e.preventDefault();
    pendingReorient = true;
    pendingStatic   = selectedStatic;
    statusEl.textContent   = `Tap on the scope to orient Launcher ${selectedStatic.id}`;
    feedbackEl.textContent = '';
    return;
  }

  // â”€â”€â”€ SINGLEâ€‘TRACK PRACTICE KEYS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (mode !== 'practice' || !['a','n','w','k'].includes(key)) return;
  e.preventDefault();
  feedbackEl.textContent = '';
  if (!selectedTrack) return;

  // â”€â”€â”€ practice keys only when in practice mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (mode !== 'practice' || !['a','n','w','k'].includes(k)) return;

  e.preventDefault();
  feedbackEl.textContent = '';

  if (!selectedTrack) return;
  const t  = selectedTrack;
  const be = ('000' + bearing(bullseye, t)).slice(-3);
  const r  = distNm(bullseye, t);

  /* â”€â”€â”€â”€â”€ NEGATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
   if (k === 'n') {
    clearTimeout(coverTimer);
    t.tag     = 'NEGATE';
    t.tagTime = Date.now();
    negatedStack.push(t);
    nextQueueTrack();            // move straight to next COVER
    return;
  }

  // â”€â”€â”€â”€â”€ AFFIRM â†’ QUEUE & PEND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (k === 'a') {
  e.preventDefault();
  clearTimeout(coverTimer);

  // mark this track AFFIRM
  const t = selectedTrack;
  t.tag     = 'AFFIRM';
  t.tagTime = Date.now();
  phase     = 'affirm';
  statusEl.textContent =
    `SL, ADAFCO, BIRDS AFFIRM Track ${t.id}, B/E ${('000'+bearing(bullseye,t)).slice(-3)}/${distNm(bullseye,t)}`;

  // remember it (no dupes)
  if (!pendingEngagements.includes(t)) pendingEngagements.push(t);

  // wait 5 seconds, then go to the next COVER
  coverTimer = setTimeout(() => {
    nextQueueTrack();
  }, 5000);

  return;
}




    /* â”€â”€â”€â”€â”€ KILL (manual only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (k === 'k') {
    e.preventDefault();
    clearTimeout(coverTimer);

    // only kill the userâ€‘selected track (the one circled on screen)
    const t = selectedTrack;
    if (!t) return;

    // mark it with â€œ#â€, then vanish it after 5â€¯s
    t.tag     = '#';
    t.tagTime = Date.now();
    setTimeout(() => {
      // clear the tag and destroy
      t.tag       = null;
      t.destroyed = true;

      // advance only if youâ€™re still in practice mode
      if (mode === 'practice') {
        if (trackQueue.every(tr => tr.destroyed)) {
          showLevelComplete();
          resetRedwood();

        } else {
          nextQueueTrack();
        }
      }
    }, 5000);

    // stop any further hotkey processing
    return;
  }
});



    // â”€â”€â”€ PRACTICE MODE INITIALIZER & QUEUE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let trackQueue = [], queueIndex = 0, negatedStack = [];


// â”€â”€â”€ QUEUE ADVANCEMENT WITH COVER TIMER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function nextQueueTrack() {
  if (mode !== 'practice') return;
  clearTimeout(coverTimer);

  // only hostiles that are alive, nonâ€‘friendly, nonâ€‘TBM **and** in detection range
  const hostiles = tracks.filter(t => {
    if (t.destroyed || t.friendly || t.isTbm) return false;
    const d = distNm(bullseye, t),
          r = getDetectionRange(t.alt);
    return d <= r;
  });
  if (hostiles.length === 0) {
    showLevelComplete();
    resetRedwood();

    return;
  }

  // 2) Pick the closest unâ€‘tagged one
  const blanks = hostiles
    .filter(t => !t.tag)
    .sort((a,b) => distNm(bullseye,a) - distNm(bullseye,b));
  if (!blanks.length) return;
  const next = blanks[0];

  // 3) Compute distance from ICC
  const icc = statics.find(s => s.type === 'icc');
  const d   = distNm(icc, next);

  // 4) Gate at a random threshold between 75â€“95â€¯NM
  //    and retry every 3â€¯s if still outside
  const threshold = 75 + Math.random() * 20;  // random in [75,95)
  if (d > threshold) {
    console.log(`SL: Track ${next.id} at ${d}â€¯NM (>${threshold.toFixed(0)}), retry in 3s`);
    coverTimer = setTimeout(nextQueueTrack, 3000);
    return;
  }

  // 5) Issue COVER once inside the threshold
  phase    = 'cover';
  curTrack = next;
  curTrack.tag     = 'COVER';
  curTrack.tagTime = Date.now();
  const b2 = ('000' + bearing(bullseye, next)).slice(-3);
  statusEl.textContent =
    `ADAFCO, SL, COVER Track ${next.id}, B/E ${b2}/${d}`;
  feedbackEl.textContent = '';

  // 6) Autoâ€‘advance again after 25â€¯s
  coverTimer = setTimeout(nextQueueTrack, 25000);
}



// â”€â”€â”€ finishEngage: scoring, negations & queue-advance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function finishEngage() {
  // 1) destroy & score
  curTrack.destroyed = true;
  curTrack.tagTime   = Date.now();
  score++;


  // who's still alive?
  const remaining = trackQueue.filter(t => !t.destroyed);

  // if none â†’ level complete
  if (remaining.length === 0) {
    showLevelComplete();
    resetRedwood();

    return;
  }
  if (curTrack.mslTimer) clearTimeout(curTrack.mslTimer);

  // revisit closest negated?
  if (negatedStack.length) {
    const neg  = negatedStack[0];
    const dNeg = distNm(bullseye, neg);
    const dMin = Math.min(...remaining.map(t => distNm(bullseye, t)));
    if (dNeg <= dMin) {
      negatedStack.shift();
      trackQueue = remaining;
      queueIndex  = remaining.indexOf(neg);
      nextQueueTrack();
      return;
      
    }
  }

  // otherwise advance normally
  trackQueue = remaining;
  queueIndex  = Math.max(0, remaining.indexOf(curTrack)) + 1;
  nextQueueTrack();
}

/**
 * (Re)builds the tracks/friendlies/TBMs for a given level
 * and kicks off practice mode on that level.
 */
 function setupLevel(lv) {
allowMissionFail = true;
  // Clear any timers
  clearTimeout(coverTimer);
  clearTimeout(killTimer);
  clearTimeoutAnyPendingTbmTimers();  // if youâ€™ve stored them
  MISSION_LOG.length = 0;


    // --- pull forward the units you want to survive the level change ----
    const keepers = tracks      // <-- tracks is the global array
        ? tracks.filter(t =>
            t.friendly || t.isTbm || t.isCruise)
        : [];

  /* â€”â€”â€”â€”â€” clean up any TBM wave timers so they donâ€™t fire after a reset â€”â€”â€”â€”â€” */
function clearTimeoutAnyPendingTbmTimers() {
  if (!Array.isArray(tbmWaves)) return;
  tbmWaves.forEach(w => {
    if (w.spawnTimer)  clearTimeout(w.spawnTimer);
    if (w.impactTimer) clearTimeout(w.impactTimer);
    // add other per-wave timer handles here if you store them
  });
  // Optional: start the list over so the old wave objects are GC-eligible
  tbmWaves = [];
}

  // Reset state
  mode             = 'practice';
  round            = 0;
  score            = 0;
  level            = lv;
  speedMultiplier  = 1;
  resetStats();               // â† add this line

   // â”€â”€ Reset NASAMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 NASAMSMissiles      = 18;
 NASAMSDisabledUntil = 0;

 // â”€â”€ Reset FIREBALL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 tbmWaves = [];
 fireballBtn.disabled = true;

// 2) Spawn 10 groups totalling 10 + 5*(level-1) hostiles
const groups   = CFG.trackCount;                // still 10 groups
// cap difficulty growth at levelÂ 4
 const effectiveLv = Math.min(lv, 4);
 const totalH      = 10 + (effectiveLv - 1) * 5;
const hostiles = newHostileGroups(groups, totalH);
tracks = hostiles.concat(keepers);

 // â”€â”€â”€â”€â”€â”€â”€â”€â”€ LEVELâ€‘BASED ADDITIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


  // 1) Levelâ€¯2+: add 3 friendlies
  if (lv >= 2) {
    const icc = statics.find(s => s.type === 'icc');
    for (let i = 0; i < 3; i++) {
      const t = newTrack();
      t.friendly = true;
      t.alt      = 200;
      t.destAlt  = 0;
      t.speed    = 500;
      t.heading  = bearing(t, icc);
      tracks.push(t);
    }
  }

  // 2) Levelâ€¯2+: add cruiseâ€missile raid
  if (lv >= 2) {
    const icc     = statics.find(s => s.type === 'icc');
    const cmCount = rand(3, 9);
    const ringNm  = rand(60, 120);
    const ang     = Math.random() * Math.PI * 2;
    const cx      = icc.x + Math.cos(ang) * (ringNm / CFG.nmPerPixel);
    const cy      = icc.y + Math.sin(ang) * (ringNm / CFG.nmPerPixel);
    for (let i = 0; i < cmCount; i++) {
      const t       = newTrack();
      const offset  = Math.random() * 15 / CFG.nmPerPixel;
      const theta   = Math.random() * Math.PI * 2;
      t.x           = cx + Math.cos(theta) * offset;
      t.y           = cy + Math.sin(theta) * offset;
      t.isCruise    = true;
      t.friendly    = false;
      t.alt         = rand(50, 100);
      t.speed       = rand(450, 550);
      t.destAlt     = 0;
      t.heading     = bearing({ x: cx, y: cy }, icc);
      tracks.push(t);
    }
  }

  // 3) Levelâ€¯3+: schedule a TBM wave
  if (lv >= 3) {
    setTimeout(spawnTbmWave, Math.random() * 2 * 60 * 1000);
  }

  // 4) Levelâ€¯4+: forced radar outages
  if (lv >= 4) {
    const now   = Date.now();
    const delay = Math.max(60_000, nextOutageAllowed - now);
    setTimeout(() => {
      const radars = statics.filter(s => s.type === 'rad');
      const s      = radars[Math.floor(Math.random() * radars.length)];
      s.disabledUntil = Date.now() + 5 * 60 * 1000;
      STATS.radarDowntime += 5 * 60;
      nextOutageAllowed = s.disabledUntil + 2 * 60 * 1000;
      const msg = 'ADAFCO, TD, system reset, launcher down for 5â€¯min';
      feedbackEl.textContent = msg;
      statusEl.textContent   = msg;
    }, delay);
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€ END LEVELâ€‘BASED ADDITIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // 3) Reset the practice queue
  trackQueue  = tracks.filter(t => !t.destroyed && !t.friendly && !t.isTbm);
  trackQueue.sort((a,b) => distNm(bullseye,a) - distNm(bullseye,b));
  queueIndex  = 0;
  negatedStack= [];

  // 4) Update button text & status
    const practiceBtn = document.getElementById('practiceBtn');
   if (practiceBtn) practiceBtn.textContent = 'Free Mode';

   fitMobileView();      // recalc scale/offX/offY for the new level âœ…
  // 5) Start
  nextQueueTrack();
}

function showReviewOverlay (menuEl) {           // <-- accept overlay
  // 1) hide the post-level menu
  menuEl.style.display = 'none';

  // 2) build the Debrief overlay
  const r = document.createElement('div');
  r.className = 'overlay';
  r.innerHTML = `
    <div class="overlayBox" style="max-width:450px;">
      <h2>Level&nbsp;${level} Debrief</h2>
      <pre style="text-align:left; font-size:0.9rem;">
Missiles fired
  PAC-2  : ${STATS.missilesUsed.pac2}
  PAC-3  : ${STATS.missilesUsed.pac3}
  MSE    : ${STATS.missilesUsed.mse}
  AIM-120: ${STATS.missilesUsed.aim120}

Effective engagements   : ${STATS.engagementsGood}
Ineffective engagements : ${STATS.engagementsBad}

TBM impacts           : ${STATS.assetsHit}
Radar downtime        : ${(STATS.radarDowntime/60)|0}Â min

<h4>Damaged Assets</h4>
<ul style="text-align:left; padding-left:1.2em; margin:0;">
  ${
    STATS.impacts.length
      ? STATS.impacts                       // [ "SW PATRIOT Radar", â€¦ ]
          .map(item => `<li>${item}</li>`)  // â†’ <li>â€¦</li><li>â€¦</li>
          .join('')
      : '<li>â€”</li>'
  }
</ul>
      <button id="closeReview">Close</button>
    </div>`;
  document.body.appendChild(r);

  // 3) when the user closes it, bring the menu back
  r.querySelector('#closeReview').onclick = () => {
    r.remove();                       // discard Debrief
    menuEl.style.display = 'flex';    // show post-level menu again
  };
}
function hardResetCurrentLevel () {
  /*  wipe every transient array & timer  */
  clearTimeout(coverTimer);
  clearTimeout(killTimer);
  tbmWaves        = [];
  pendingEngagements.length = 0;
  missiles.length = 0;
  bombs.length    = 0;

  /*  restore score-keeping & state flags  */
  assetHits        = 0;
  fratricideFatal  = false;
  resetRedwood();          // close HOT quadrants, reset colours
  resetStats();            // zero the debrief counters
  resetLaunchersAndRadars();

  /*  build the level exactly like the first time  */
  setupLevel(level);       // you already wrote this routine
}



function showLevelComplete(forceFail = false) {
      mode   = 'paused';
  paused = true;     // freeze the world as soon as the overlay comes up
    // â¬…ï¸ ADD THIS
    const success = !forceFail && score > 0;
// â”€â”€â”€ make sure we never keep duplicates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const old = document.getElementById('levelOverlay');
if (old) old.remove();

  clearTimeout(coverTimer);

  // 1) decide pass / fail
  const pass = score >= 0;

  // 2) overlay markup
  const ov = document.createElement('div');
ov.id = 'levelOverlay';
ov.innerHTML = `
  <div id="levelBox">
    <h2>Level ${level} â€“ ${success ? 'Mission Success' : 'Mission Fail'}</h2>
    <p>Score: ${score}</p>
    <button id="nextBtn">Next Level Â»</button>
    <button id="reviewBtn">Review Data</button>
    <button id="logsBtn">Mission Logs</button>
    <button id="contBtn">Keep Fighting</button>
    <button id="retryBtn">Try Again?</button>
  </div>`;

/* 1ï¸âƒ£ append first â€¦ */
document.body.appendChild(ov);

/* 2ï¸âƒ£ â€¦then hook up all the buttons *inside* the overlay */
ov.querySelector('#logsBtn')
  .addEventListener('click', () => showLogsOverlay(ov));

ov.querySelector('#nextBtn')
  .addEventListener('click', () => { ov.remove(); paused = false; level++; setupLevel(level); });

  ov.querySelector('#contBtn')
  .addEventListener('click', () => {
    ov.remove();
    paused = false;
    mode = 'practice';         // go back into practice mode
    allowMissionFail = false;  // disable missionâ€‘fail triggers

    // rebuild the hostiles queue so input works and level can end naturally
    trackQueue   = tracks.filter(t => !t.destroyed && !t.friendly && !t.isTbm);
    queueIndex   = 0;
    negatedStack = [];

    nextQueueTrack();
  });

ov.querySelector('#retryBtn')
  .addEventListener('click', () => { ov.remove(); paused = false; hardResetCurrentLevel(); });

ov.querySelector('#reviewBtn')
  .addEventListener('click', () => showReviewOverlay(ov));

  setTimeout(() => {
    ov.remove();
    round = 0;
    level++;

    

    // â”€â”€â”€ REBUILD HOSTILES ONLY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 1) pull out all the friendlies and TBMs we want to keep
     const keepers = tracks.filter(t =>
   t.friendly || t.isTbm || t.isCruise
 );

// 1.5) force every friendly to start at 200â€¯MSL
keepers.forEach(t => {
  if (t.friendly) {
    t.alt     = 200;
    t.destAlt = 0;
  }
});

// 2) rebuild 10 groups totalling 10 + 5*(level-1) hostiles
const totalH    = 10 + (level - 1) * 5;                    // lvl1=10, lvl2=15, lvl3=20â€¦
const newHostiles = newHostileGroups(CFG.trackCount, totalH);
tracks = newHostiles.concat(keepers);
updateVisibility();            // ensure no flash on level load


    // â”€â”€â”€ REâ€‘QUEUE EVERYTHING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    trackQueue = tracks.filter(t => !t.destroyed && !t.friendly && !t.isTbm);
    trackQueue.sort((a, b) => distNm(bullseye, a) - distNm(bullseye, b));
    queueIndex   = 0;
    negatedStack = [];

    mode = 'practice';
    nextQueueTrack();

  }, 300000);
}


// â”€â”€â”€ showFinalScore: final-game overlay + full reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showFinalScore() {
  mode = 'gameover';
  clearTimeout(coverTimer);
  clearTimeout(killTimer);

  const ov = document.createElement('div');
  ov.id = 'gameOverOverlay';
  ov.innerHTML = `
    <div id="gameOverBox">
      <h1>FINAL SCORE</h1>
      <p>${score} point${score===1?'':'s'}</p>
      <button id="retryBtn">TRY AGAIN?</button>
    </div>`;
  document.body.appendChild(ov);

  document.getElementById('retryBtn').onclick = () => {
    ov.remove();
    // full reset
    level           = 1;
    speedMultiplier = 1;
    score           = 0;
    tracks.forEach(t=>t.destroyed=false);
    initTracks();
    document.getElementById('practiceBtn').click();
  };
}



function showGameOver(reason) {
  // 1) Stop the game
  mode = 'gameover';
  clearTimeout(coverTimer);
  clearTimeout(killTimer);

  // 2) Apply centerâ€‘hit penalty
  if (reason === 'center') {
    score -= 0;
    updateScoreDisplay();
  }

  // 3) Build the overlay
  const ov = document.createElement('div');
  ov.id = 'gameOverOverlay';
  ov.innerHTML = `
    <div id="gameOverBox">
      <h1>FINAL SCORE</h1>
      <p>${score} point${score === 1 ? '' : 's'}</p>
      <button id="tryAgainBtn">TRY AGAIN?</button>
    </div>`;
  document.body.appendChild(ov);

  // 4) Try Again just reloads the page
  document.getElementById('tryAgainBtn').onclick = () => {
    ov.remove();
resetLaunchersAndRadars();
hardResetCurrentLevel();

  };
}




    // TAGS, HELP, MOBILE buttons
    tagsBtn.addEventListener('click', e => {
  e.preventDefault();
  tagMode = (tagMode + 1) % tagLabels.length;
  tagsBtn.textContent = `TAGS: ${tagLabels[tagMode]}`;
});

    document.getElementById('helpBtn').onclick=()=>helpOverlay.style.display='block';
    document.getElementById('closeHelp').onclick=()=>helpOverlay.style.display='none';
    document.querySelectorAll('#mobileControls button[data-key]').forEach(btn => {
  btn.addEventListener('click', e => {
    e.preventDefault();
    e.stopPropagation();
    window.dispatchEvent(new KeyboardEvent('keydown', { key: btn.dataset.key }));
  });
});


    //help with scoring TBMs
    const scoreEl = document.getElementById('score');
    function updateScoreDisplay() {
  // In Bullseye (â€œfreeâ€) show the Bullseye score,
  // otherwise show the main â€œscoreâ€ for Air Battle.
  const val = (mode === 'free')
    ? beLevelScore
    : score;
  scoreEl.textContent = `Score: ${val}`;
}
// initialize
updateScoreDisplay();
/**
 * Change the score, update the display, and show a feedback message.
 * @param {number} delta  positive or negative points
 * @param {string} msg    feedback text to show
 */
 function changeScore(delta, msg) {
  score += delta;
  updateScoreDisplay();
  feedbackEl.textContent = msg;
    // â”€â”€ fatal-event bookkeeping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (msg.includes('Fratricide'))               fratricideFatal = true;
  if (msg.match(/damaged|Impact|CRATER/))       assetHits++;

  // auto-end level if rules crossed
   if (allowMissionFail && (fratricideFatal || assetHits >= 5)) {
   showLevelComplete(true);
 }
}

    // COMPASS toggle
    compassBtn.onclick = ()=>{
      compassOn = !compassOn;
      compassBtn.textContent = `Compass: ${compassOn ? 'ON' : 'OFF'}`;
    };

 
    </script>

</body>
</html>
